{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-it","title":"What is it?","text":"<p>NetCDF95 is an alternative Fortran interface to the NetCDF library. The official Fortran interface is the Fortran 90 NetCDF interface.</p> <p>The name NetCDF95 was at first a reference to the Fortran 95 standard but NetCDF95 now uses Fortran 2003 features.</p> <p>Author: Lionel GUEZ</p>"},{"location":"#why-an-alternative-interface","title":"Why an alternative interface?","text":"<p>Compared to the the Fortran 90 NetCDF interface, NetCDF95 is meant to be friendlier and more secure. Notably:</p> <ul> <li>NetCDF95 frees you of the cumbersome task of handling the error   status.  NetCDF95 procedures behave like the Fortran input/output   statements. That is, the error status is an optional output   argument. Consider, for example, the Fortran formatted <code>read</code>   statement:<pre><code>read([unit=]u, [fmt=]fmt [,iostat=ios] [, err=error-label] &amp;\n   [,end=end-label]) [list]\n</code></pre> </li> </ul> <p>If the <code>err</code>, <code>end</code> and <code>iostat</code> keywords are not provided, and   there is a problem in the execution of the <code>read</code> statement, then   execution of the program stops (with an informative error message   from the compiler). Similarly, NetCDF95 procedures have an optional   argument for error status. If the optional argument is absent and   there is an error, then the NetCDF95 procedure produces an error   message and stops the program. (The official Fortran 90 interface   looks like it has been made to mimic the C interface, and this is   not optimal in Fortran.)</p> <ul> <li> <p>NetCDF95 frees you of assumptions on the size of arrays and the size   of character strings when you call several inquiry procedures. (It   does so by making use of allocatable arguments, a Fortran 2003   feature.) See   <code>nf95_inquire_variable</code>,   <code>nf95_inq_grpname</code>,   <code>nf95_inq_grps</code>,   <code>nf95_inq_grpname_full</code>,   <code>nf95_inq_attname</code>.</p> </li> <li> <p>NetCDF95 offers procedures that have no counterpart in the official   interface. These combine several calls to other NetCDF95 procedures   for common higher-level tasks. See   <code>nf95_gw_var</code>,   <code>nf95_find_coord</code>,   <code>nf95_create_single</code>,   <code>nf95_get_missing</code>,   <code>nf95_gunp_var</code>.</p> </li> <li> <p>NetCDF95 replaces functions by subroutines. Procedures of the   official Fortran 90 interface are all functions, and they are all   with side effects. First, they have <code>intent(out)</code>   arguments. Furthermore, there is obviously data transfer inside the   procedures. Any data transfer inside a function is considered as a   side effect. In this respect, the Fortran 90 interface mimics the C   interface. But Fortran has a different programming style than C and   frowns upon side-effects in functions. See for example Metcalf and   Reid (Fortran 90/95 Explained, 1999, \u00a7\u00a7 5.10 and 6.10).</p> </li> <li> <p>NetCDF95 provides the procedure <code>nf95_inq_varnatts</code>, corresponding   to the strangely missing   <code>nf90_inq_varnatts</code> in the official   Fortran 90 interface.</p> </li> <li> <p>There are other improvements such as securing the call to   <code>nf95_get_var</code> by checking the   arguments start and <code>count_nc</code>, and renaming badly chosen argument   names len and count to nclen and <code>count_nc</code>.</p> </li> </ul>"},{"location":"changes/","title":"Changes before version control","text":"<p>(See Github page for more recent changes.)</p> <ul> <li>October 12th, 2017.<ul> <li>NetCDF95 is now in Fortran 2003. Uses allocatable dummy     arguments. The actual argument of <code>nf95_gw_var</code> corresponding to     dummy argument <code>dimids</code> must now be allocatable and not pointer.     The actual argument of <code>nf95_inquire_variable</code> corresponding to     dummy argument <code>value</code> must now be allocatable and not pointer.</li> <li><code>find_coord</code> accepts \"plev\" as standard name.</li> <li>Added specific procedure <code>nf95_get_var_2D_FourByteInt</code> to     generic <code>nf95_get_var</code> and specific <code>nf95_gw_var_int_2d</code>to     generic <code>nf95_gw_var</code>.</li> </ul> </li> <li>October 10th, 2014. Added <code>nf95_sync</code>. Added specific procedure in     <code>nf95_put_var</code>. <code>nf95_get_var</code> and <code>nf95_put_var</code> now check that :     the size of arguments <code>start</code> and <code>count_nc</code> equals the rank of the     NetCDF variable ; if <code>count_nc</code> is absent, the rank of argument     <code>values</code> is lower than or equal to the rank of the NetCDF variable.</li> <li>February 13th, 2013, added specific procedures in <code>nf95_gw_var</code> and     <code>nf95_put_att</code>.</li> <li>March 22nd, 2012, added <code>nf95_inquire_attribute</code> and <code>nf95_inquire</code>.     Fixed <code>nf95_get_att</code>: does not exit if argument <code>ncerr</code> is present     and there is an error picked by <code>nf90_inquire_attribute</code>.</li> <li>January 24th, 2012, added specific procedures in <code>nf95_get_var</code> and     <code>nf95_gw_var</code>.</li> <li>November 3rd, 2010, added <code>nf95_get_var</code>.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li> <p>CMake (version \u2265 3.16)<sup>1</sup>.</p> </li> <li> <p>The NetCDF-C   library   (version \u2265 4.6).</p> </li> <li> <p>The NetCDF-Fortran   library   (version \u2265 4.5).</p> </li> <li> <p>The Fortran compiler that was used to compile your installed   NetCDF-Fortran library.</p> </li> <li>Git (optional, the easiest way to download NetCDF95).</li> </ul> <p>Under Ubuntu \u2265 20.04 or Linux Mint \u2265 20, you can install all these dependencies with the following command:</p> <pre><code>sudo apt install libnetcdff-dev gfortran cmake git\n</code></pre>"},{"location":"installation/#instructions","title":"Instructions","text":"<ol> <li> <p>Get NetCDF95 from Github. As    the Git repository contains a submodule, the easiest way is to    type:</p> <pre><code>git clone --recurse-submodules https://github.com/lguez/NetCDF95.git\n</code></pre> <p>If you prefer to download a ZIP file then you will also have to download the cmake subdirectory.</p> </li> <li> <p>Create a build subdirectory in the NetCDF95 directory you have     just downloaded:</p> <pre><code>cd NetCDF95\nmkdir build\ncd build\n</code></pre> </li> <li> <p>Decide in which directory you want to install NetCDF95 after     compilation and type the command below with your choice of     directory after <code>-DCMAKE_INSTALL_PREFIX=</code> (enter an absolute     path). For example:</p> <pre><code>cmake .. -DCMAKE_INSTALL_PREFIX=~/.local\n</code></pre> </li> <li> <p>Type:</p> <pre><code>make install\n</code></pre> </li> </ol> <p>You do not need to keep the downloaded directory NetCDF95 (nor the build directory) after installation.</p>"},{"location":"installation/#advanced-instructions","title":"Advanced instructions","text":"<p>Most users should not need these advanded instructions.</p> <ul> <li> <p>You can choose any name and any location for the build   directory. You have to refer to the source directory when you run   cmake from the build directory:</p> <pre><code>mkdir /wherever/any/name\ncd /wherever/any/name\ncmake /where/I/downloaded/NetCDF95 -DCMAKE_INSTALL_PREFIX=~/.local\n</code></pre> </li> <li> <p>NetCDF95 assumes that the Fortran default character kind is the same   as the C character kind (the official NetCDF-Fortran interface makes   the same assumption). You can test this by running the command   <code>ctest</code> in the build directory. If this test fails then the   procedures <code>nf95_inq_grpname</code>, <code>nf95_inq_grpname_full</code>,   <code>nf95_inq_grp_full_ncid</code> and <code>nf95_get_att_text</code> are not reliable.</p> </li> <li> <p>You do not have to install. You can just use the compiled library in   the build directory. So you do not have to specify the option   <code>-DCMAKE_INSTALL_PREFIX=</code> and you can just type <code>make</code> instead of   <code>make install</code>.</p> </li> <li> <p>You can compile with debugging options by adding the option   <code>-DCMAKE_BUILD_TYPE=Debug</code> to the command cmake.</p> </li> </ul>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <p>If your installation of NetCDF or NetCDF-Fortran is in a   non-standard location, and CMake does not find it, then re-run cmake   setting the variable <code>CMAKE_PREFIX_PATH</code> to the directory containing   it. CMake will then search <code>${CMAKE_PREFIX_PATH}/lib</code>,   <code>${CMAKE_PREFIX_PATH}/include</code>, etc. For example, if you want to use   the parallel-enabled version of NetCDF-C on Ubuntu or Linux Mint:</p> <pre><code>cmake . -DCMAKE_PREFIX_PATH:PATH=/usr/lib/x86_64-linux-gnu/netcdf/mpi\n</code></pre> </li> <li> <p>If you have several Fortran compilers on your machine, it is   possible that CMake does not choose the one you want. Note that when   you run cmake, it prints a line telling which compiler it is going   to use. For example :</p> <pre><code>-- The Fortran compiler identification is GNU 11.3.0\n</code></pre> <p>So if you want another compiler, remove everything in the build directory and run cmake again setting the variable FC to the compiler you want. For example:</p> <pre><code>rm -r * # in the build directory!\nFC=ifort cmake .. -DCMAKE_INSTALL_PREFIX=~/.local\n</code></pre> </li> </ul> <ol> <li> <p>On Mac OS, after downloading the application from the CMake web site, run it, then click on \u201cHow to Install For Command Line Use\u201d in the Tools menu.\u00a0\u21a9</p> </li> </ol>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#in-the-source-code-of-the-consumer-program","title":"In the source code of the consumer program","text":"<p>The name of the module that you must use in your Fortran program is <code>netcdf95</code>. For example:</p> <pre><code>use netcdf95, only: nf95_open, nf95_nowrite, nf95_inq_varid, nf95_gw_var, &amp;\n    nf95_close\n</code></pre>"},{"location":"usage/#building-the-consumer-program-with-cmake","title":"Building the consumer program with CMake","text":"<p>If you build your program using NetCDF95 with CMake, then download both <code>FindNetCDF_Fortran.cmake</code> and <code>FindnetCDF.cmake</code> into the directory of your consumer program and add the following lines to the file <code>CMakeLists.txt</code> for your program:</p> <pre><code>find_package(NetCDF_Fortran REQUIRED)\nfind_package(NetCDF95 CONFIG REQUIRED)\ntarget_link_libraries(my_program PRIVATE NetCDF95::netcdf95\n  NetCDF_Fortran::netcdff)\n</code></pre> <p>(replace <code>my_program</code> by the name of your target).</p>"},{"location":"usage/#building-the-consumer-program-without-cmake","title":"Building the consumer program without CMake","text":"<p>If you do not build the consumer program with CMake, take into account that your program will require <code>netcdf95.mod</code> (and possibly other <code>.mod</code> files produced by compilation of NetCDF95) at compile time and <code>libnetcdf95.a</code> at link time. Note that NetCDF95 uses the Fortran 90 NetCDF interface, so you must keep the options you would use for direct access to the Fortran 90 NetCDF interface.</p> <p>For most compilers, the options you will need to add are:</p> <pre><code>-I$netcdf95_inc_dir\n</code></pre> <p>at compile time and:</p> <pre><code>-L$netcdf95_lib_dir -L$netcdf90_lib_dir -lnetcdf95 -lnetcdff -lnetcdf\n</code></pre> <p>at link time, where <code>$netcdf95_inc_dir</code> is the directory where you put <code>.mod</code> files produced by compilation of NetCDF95, <code>$netcdf95_lib_dir</code> is the directory where you put <code>libnetcdf95.a</code> and <code>$netcdf90_lib_dir</code> is the directory where the Fortran 90 NetCDF interface is installed.</p>"},{"location":"Detailed_content/attributes/","title":"Attributes","text":"<p>This page describles procedures handling NetCDF attributes.</p> <p>See the improvements page for an explanation of the mnemonics \u201cbasic change\u201d, \u201cinterface change\u201d, \u201cfunctionality change\u201d, \u201cadditional procedure\u201d.</p>"},{"location":"Detailed_content/attributes/#nf95_copy_att","title":"<code>nf95_copy_att</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_copy_att(ncid_in, varid_in, name, ncid_out, varid_out, ncerr)\n    integer, intent( in):: ncid_in,  varid_in\n    character(len=*), intent( in):: name\n    integer, intent( in):: ncid_out, varid_out\n    integer, intent(out), optional:: ncerr\n</code></pre> <p>Reference: <code>nf90_copy_att</code></p>"},{"location":"Detailed_content/attributes/#nf95_get_att","title":"<code>nf95_get_att</code>","text":"<p>(functionality change)</p> <pre><code>  subroutine nf95_get_att(ncid, varid, name, values, ncerr)\n    integer,                          intent( in) :: ncid, varid\n    character(len = *),               intent( in) :: name\n    character(len = *), integer(any kind) or real(any kind), intent(out) :: values\n    integer, intent(out), optional:: ncerr\n</code></pre> <p><code>nf95_get_att</code> is more secure than <code>nf90_get_att</code>. For an argument <code>values</code> of type <code>character</code>, <code>nf95_get_att</code> checks that the <code>values</code> argument is long enough and removes the null terminator, if any. For a numeric scalar <code>values</code> argument, <code>nf95_get_att</code> checks that the attribute contains a single value.</p> <p>Reference: <code>nf90_get_att</code></p>"},{"location":"Detailed_content/attributes/#nf95_get_missing","title":"<code>nf95_get_missing</code>","text":"<p>(additional procedure)</p> <pre><code>subroutine nf95_get_missing(ncid, varid, missing)\n\n  integer, intent(in)::  ncid, varid\n\n  real or double precision or integer, of any kind, or character, intent(out):: missing\n  ! missing or fill value\n</code></pre> <p>The procedure returns the <code>missing_value</code> or <code>_FillValue</code> attribute if one of them is present, else the <code>nf95_fill_type</code> constant corresponding to the type of argument <code>missing</code>. If both <code>missing_value</code> and <code>_FillValue</code> are present then the procedure checks that they are equal.</p> <p>If the type of the <code>missing_value</code> or <code>_FillValue</code> attribute is different than the type of argument <code>missing</code> then conversion will occur. The procedure prints a warning as this is dangerous usage. Indeed, if you read values of the corresponding NetCDF variable without conversion then the converted missing value from the attribute may not correspond to the un-converted value in the NetCDF variable. And if you read values of the NetCDF variable with the same conversion as for the attribute, then values which are valid but close to the missing value in the NetCDF variable may become equal to the missing value after conversion. See the (admittedly contrived) examples in file <code>Tests/test_get_missing.f90</code> which demonstrate this risk. Concluding advice: if you convert missing value from double precision real to single precision real, for example, be sure to convert also values of the NetCDF variable, and make sure that there are no values close to the missing value in the NetCDF variable.</p>"},{"location":"Detailed_content/attributes/#nf95_inq_attname","title":"<code>nf95_inq_attname</code>","text":"<p>(interface change)</p> <pre><code>subroutine nf95_inq_attname(ncid, varid, attnum, name, ncerr)\n\n  integer, intent(in):: ncid, varid, attnum\n  character(len = :), allocatable, intent(out):: name\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>The argument name has dynamic (deferred) length in <code>nf95_inq_attname</code> instead of assumed length in <code>nf90_inq_attname</code>. So you do not have to worry about a maximum length for the corresponding actual argument: just declare it also as <code>character(len = :), allocatable</code>.</p>"},{"location":"Detailed_content/attributes/#nf95_inquire_attribute","title":"<code>nf95_inquire_attribute</code>","text":"<p>(interface change)</p> <pre><code>subroutine nf95_inquire_attribute(ncid, varid, name, xtype, nclen, attnum, &amp;\n     ncerr)\n\n  integer, intent( in)     :: ncid, varid\n  character (len = *), intent( in)     :: name\n  integer, intent(out), optional :: xtype, nclen, attnum\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>The argument for the number of values or characters of the attribute is called <code>nclen</code> in <code>nf95_inquire_attribute</code>, instead of <code>len</code> in <code>nf90_inquire_attribute</code>. <code>len</code> is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure.</p> <p>Reference: <code>nf90_inquire_attribute</code></p>"},{"location":"Detailed_content/attributes/#nf95_put_att","title":"<code>nf95_put_att</code>","text":"<p>(basic change)</p> <pre><code>subroutine nf95_put_att(ncid, varid, name, values, ncerr)\n  integer, intent(in) :: ncid, varid\n  character(len = *), intent(in) :: name\n  character(len = *) or integer(any kind) or real(any kind), intent(in) :: values\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>Reference: <code>nf90_put_att</code></p>"},{"location":"Detailed_content/datasets/","title":"Datasets &amp; co","text":"<p>This page describles procedures handling a whole dataset, or handling a combination of NetCDF variables, dimensions or attributes.</p> <p>See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\".</p>"},{"location":"Detailed_content/datasets/#nf95_close","title":"<code>nf95_close</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_close(ncid, ncerr)\n    integer, intent( in) :: ncid\n    integer, intent(out), optional :: ncerr\n</code></pre> <p>Reference: <code>nf90_close</code></p>"},{"location":"Detailed_content/datasets/#nf95_create","title":"<code>nf95_create</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_create(path, cmode, ncid, initialsize, chunksize, ncerr)\n    character (len = *), intent(in   ) :: path\n    integer,             intent(in   ) :: cmode\n    integer,             intent(  out) :: ncid\n    integer, optional,   intent(in   ) :: initialsize\n    integer, optional,   intent(inout) :: chunksize\n    integer, intent(out), optional :: ncerr\n</code></pre> <p>Reference: <code>nf90_create</code></p>"},{"location":"Detailed_content/datasets/#nf95_create_single","title":"<code>nf95_create_single</code>","text":"<p>(additional procedure)</p> <pre><code>subroutine nf95_create_single(name, coordinates, ncid, varid, varid_coord)\n  character(len = *), intent(in):: name\n  type(coord_def), intent(in):: coordinates(:)\n  integer, intent(out):: ncid, varid, varid_coord(:)\n</code></pre> <p>This procedure is a shortcut to create a NetCDF file containing a single primary variable, with all its coordinates. The coordinates are specified using the derived type <code>coord_def</code> :</p> <pre><code>type coord_def\n  character(len = NF95_MAX_NAME) name\n  integer nclen\n  character(len = :), allocatable:: attr_name(:), attr_val(:)\nend type coord_def\n</code></pre> <p>The arrays <code>attr_name</code> and <code>attr_val</code> must have the same size. They define the attributes of the coordinate. After the call to <code>nf95_create_single</code>, the NetCDF dataset is still in define mode, so you can add attributes to the primary variable if appropriate.</p>"},{"location":"Detailed_content/datasets/#nf95_enddef","title":"<code>nf95_enddef</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_enddef(ncid, h_minfree, v_align, v_minfree, r_align, ncerr)\n    integer,           intent( in) :: ncid\n    integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align\n    integer, intent(out), optional :: ncerr\n</code></pre> <p>Reference: <code>nf90_enddef</code></p>"},{"location":"Detailed_content/datasets/#nf95_find_coord","title":"<code>nf95_find_coord</code>","text":"<p>(additional procedure)</p> <pre><code>subroutine nf95_find_coord(ncid, name, dimid, varid, std_name, ncerr)\n\n  integer, intent(in):: ncid\n\n  character(len=*), intent(out), optional:: name ! blanks if not found\n  ! The actual character argument should normally have the length\n  ! \"NF90_MAX_NAME\".\n\n  integer, intent(out), optional:: dimid ! 0 if not found\n  integer, intent(out), optional:: varid ! 0 if not found\n\n  character(len=*), intent(in):: std_name\n  ! standard name : \"plev\", \"latitude\", \"longitude\" or \"time\"\n\n  integer, intent(out), optional:: ncerr ! nf95_noerr if found\n</code></pre> <p>This procedure returns the name, dimension id or variable id of the NetCDF coordinate with standard name <code>std_name</code>, if such a coordinate exists. A NetCDF coordinate is defined as a rank-one variable with the same name as its dimension. The standard name is only used to know what to search, it is not used for the search itself. The search itself is done via a string match on the attribute \"units\". So the NetCDF variable one looks for does not need to have the attribute <code>std_name</code>. The procedure aborts if the coordinate is not found and argument ncerr is not present.</p>"},{"location":"Detailed_content/datasets/#nf95_inquire","title":"<code>nf95_inquire</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_inquire(ncid, nDimensions, nVariables, nAttributes, &amp;\n       unlimitedDimId, formatNum, ncerr)\n\n    integer,           intent( in) :: ncid\n    integer, optional, intent(out) :: nDimensions, nVariables, nAttributes\n    integer, optional, intent(out) :: unlimitedDimId, formatNum\n    integer, intent(out), optional:: ncerr\n</code></pre> <p>Reference: <code>nf90_inquire</code></p>"},{"location":"Detailed_content/datasets/#nf95_open","title":"<code>nf95_open</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_open(path, mode, ncid, chunksize, ncerr)\n    character(len=*), intent(in):: path\n    integer, intent(in):: mode\n    integer, intent(out):: ncid\n    integer, intent(inout), optional:: chunksize\n    integer, intent(out), optional:: ncerr\n</code></pre> <p>Reference: <code>nf90_open</code></p>"},{"location":"Detailed_content/datasets/#nf95_redef","title":"<code>nf95_redef</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_redef(ncid, ncerr)\n    integer, intent( in) :: ncid\n    integer, intent(out), optional :: ncerr\n</code></pre> <p>Reference: <code>nf90_redef</code></p>"},{"location":"Detailed_content/datasets/#nf95_sync","title":"<code>nf95_sync</code>","text":"<p>(basic change)</p> <pre><code>subroutine nf95_sync(ncid, ncerr)\n\n    integer, intent( in) :: ncid\n    integer, intent(out), optional :: ncerr\n</code></pre>"},{"location":"Detailed_content/dimensions/","title":"Dimensions","text":"<p>This page describles procedures handling NetCDF dimensions.</p> <p>See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\".</p>"},{"location":"Detailed_content/dimensions/#nf95_def_dim","title":"<code>nf95_def_dim</code>","text":"<p>(interface change)</p> <pre><code>  subroutine nf95_def_dim(ncid, name, nclen, dimid, ncerr)\n    integer,             intent( in) :: ncid\n    character (len = *), intent( in) :: name\n    integer,             intent( in) :: nclen\n    integer,             intent(out) :: dimid\n    integer, intent(out), optional :: ncerr\n</code></pre> <p>The argument for the length of the dimension is called <code>nclen</code> in <code>nf95_def_dim</code>, instead of <code>len</code> in <code>nf90_def_dim</code>. <code>len</code> is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure.</p> <p>Reference: <code>nf90_def_dim</code></p>"},{"location":"Detailed_content/dimensions/#nf95_inq_dimid","title":"<code>nf95_inq_dimid</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_inq_dimid(ncid, name, dimid, ncerr)\n    integer,             intent(in) :: ncid\n    character (len = *), intent(in) :: name\n    integer,             intent(out) :: dimid\n    integer, intent(out), optional:: ncerr\n</code></pre> <p>Reference: <code>nf90_inq_dimid</code></p>"},{"location":"Detailed_content/dimensions/#nf95_inquire_dimension","title":"<code>nf95_inquire_dimension</code>","text":"<p>(interface change)</p> <pre><code>  subroutine nf95_inquire_dimension(ncid, dimid, name, nclen, ncerr)\n    integer,                       intent( in) :: ncid, dimid\n    character (len = *), optional, intent(out) :: name\n    integer,             optional, intent(out) :: nclen\n    integer, intent(out), optional:: ncerr\n</code></pre> <p>The argument for the length of the dimension is called <code>nclen</code> in <code>nf95_inquire_dimension</code>, instead of <code>len</code> in <code>nf90_inquire_dimension</code>. <code>len</code> is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure.</p> <p>Reference: <code>nf90_inquire_dimension</code></p>"},{"location":"Detailed_content/errors/","title":"Handling of errors","text":"<p>If you call a NetCDF95 procedure without the optional <code>ncerr</code> argument, and some error occurs, then the NetCDF95 procedure will:</p> <ul> <li>write to standard output all the information it has, including the     string produced by <code>nf90_strerror</code>;</li> <li>try to close the NetCDF file;</li> <li>stop the program, with an exit status of 1.</li> </ul> <p>For example, if some error occurs within a call to <code>nf95_inq_varid</code>, <code>nf95_inq_varid</code> will write to standard output:</p> <pre><code>nf95_inq_varid, name = &lt; name of the variable you inquired about &gt;:\n&lt; string produced by nf90_strerror &gt;\n</code></pre>"},{"location":"Detailed_content/errors/#nf95_abort","title":"<code>nf95_abort</code>","text":"<p>(additional procedure)</p> <pre><code>subroutine nf95_abort(message, ncerr, ncid, varid)\n  character(len=*), intent(in):: message\n  ! (should include name of calling procedure)\n\n  integer, intent(in):: ncerr\n\n  integer, intent(in), optional :: ncid\n  ! This can be the file ncid or a group ncid. Provide this argument\n  ! if you want nf95_abort to try to close the file.\n\n  integer, intent(in), optional :: varid\n</code></pre> <p>This is a public procedure which is also used internally in NetCDF95. <code>nf95_abort</code> prints a message and stops the program. <code>nf95_abort</code> may also be useful after calling procedures of the Fortran 90 interface that have not been implemented in NetCDF95.</p> <p>You should include the name of the calling procedure in the <code>message</code> argument. Provide the <code>ncid</code> argument if you want <code>nf95_abort</code> to try to close the file. Provide <code>varid</code> if you want <code>nf95_abort</code> to print it.</p>"},{"location":"Detailed_content/groups/","title":"Groups","text":"<p>This page describles procedures handling NetCDF groups.</p> <p>See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\".</p>"},{"location":"Detailed_content/groups/#nf95_inq_file_ncid","title":"<code>nf95_inq_file_ncid</code>","text":"<p>(additional procedure)</p> <pre><code>subroutine nf95_inq_file_ncid(ncid_file, grpid, ncerr)\n\n  ! Find the ncid of the file (that is, the root group), knowing the\n  ! ncid of a group in the file.\n\n  integer, intent(out):: ncid_file\n  integer, intent(in):: grpid\n  integer, intent(out), optional:: ncerr\n</code></pre>"},{"location":"Detailed_content/groups/#nf95_inq_grp_full_ncid","title":"<code>nf95_inq_grp_full_ncid</code>","text":"<p>(basic change)</p> <pre><code>subroutine nf95_inq_grp_full_ncid(ncid, full_name, grp_ncid, ncerr)\n\n  integer, intent(in):: ncid ! can be the file id or a group id\n\n  character(len = *), intent(in):: full_name\n  ! Should be a path relative to ncid (which can correspond to the\n  ! root group or a subgroup). Can be an immediate subgroup or a\n  ! deeper subgroup.\n\n  integer, intent(out):: grp_ncid\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>You know the relative path of a group and you want its ncid.</p> <p>Reference: <code>nc_inq_grp_full_ncid</code></p>"},{"location":"Detailed_content/groups/#nf95_inq_grpname","title":"<code>nf95_inq_grpname</code>","text":"<p>(functionality change)</p> <pre><code>subroutine nf95_inq_grpname(ncid, name, ncerr)\n\n  integer, intent(in):: ncid ! can be the file id or a group id\n  character(len = :), allocatable, intent(out):: name ! without path\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>You know the ncid of a group (which can be the root group) and you want the basename of this group. The basename of the group is the last part in the absolute path, as in the Unix basename program. The basename of the root group is \u201c/\u201d.</p> <p>The functionality change is that the argument <code>name</code> has dynamic, deferred length.</p> <p>The problem with the Fortran 90 interface: <code>name</code> has assumed length in the Fortran 90 interface. Also, there is no way in the Fortran 90 interface to only inquire about the length of the name. The function <code>nf90_inq_grpname_len</code> gives the length of the absolute path of the group, not the length of the basename of the group.</p> <p>Reference: <code>nf90_inq_grpname</code></p>"},{"location":"Detailed_content/groups/#nf95_inq_grpname_full","title":"<code>nf95_inq_grpname_full</code>","text":"<p>(functionality change)</p> <pre><code>subroutine nf95_inq_grpname_full(ncid, full_name, ncerr)\n\n  integer, intent(in):: ncid\n  character(len = :), allocatable, intent(out):: full_name ! absolute path\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>You know the ncid of a group (which can be the root group) and you want the absolute path of the group.</p> <p>The functionality change is that the argument <code>full_name</code> has dynamic, deferred length, and there is no length argument. Since <code>full_name</code> is allocated to the exact length of the path, the length argument is useless, you can just query the length of the actual argument after the call.</p> <p>The problem with the Fortran 90 interface: the name argument has assumed length in the Fortran 90 interface. You have to call <code>nf90_inq_grpname_len</code> first to know the length of the actual argument that you will associate to name.</p> <p>Reference: <code>nf90_inq_grpname_full</code></p>"},{"location":"Detailed_content/groups/#nf95_inq_grp_parent","title":"<code>nf95_inq_grp_parent</code>","text":"<p>(basic change)</p> <pre><code>subroutine nf95_inq_grp_parent(ncid, parent_ncid, ncerr)\n\n  integer, intent(in):: ncid\n  integer, intent(out):: parent_ncid\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>You know the ncid of a group and you want the ncid of the parent group.</p>"},{"location":"Detailed_content/groups/#nf95_inq_grps","title":"<code>nf95_inq_grps</code>","text":"<p>(functionality change)</p> <pre><code>subroutine nf95_inq_grps(ncid, ncids, ncerr)\n\n  integer, intent(in):: ncid ! can be the file id or a group id\n  integer, allocatable, intent(out):: ncids(:)\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>You know the ncid of a group (which can be the root group) and you want the ncids of its immediate subgroups.</p> <p>The functionality change is that the argument ncids is allocatable and there is no argument numgrps. Since ncids is allocated to the number of groups, the argument numgrps is useless, you can just query the size of the actual argument associated to ncids after the call.</p> <p>The problem with the Fortran 90 interface: ncids has assumed shape in the Fortran 90 interface. Also, there is no way in the Fortran 90 interface to only inquire about the number of subgroups. The Fortran 90 interface is dangerous here because it does not check that the size of ncids is large enough: a segmentation violation will occur if it is not. NetCDF95 solves this by going directly to the C interface.</p> <p>Reference: <code>nf90_inq_grps</code> and <code>nc_inq_grps</code></p>"},{"location":"Detailed_content/improvements/","title":"The four types of improvements","text":"<p>In the following documentation, we give a description of the interface of each NetCDF95 procedure. We will label each NetCDF95 procedure with one of the following four (mutually exclusive) mnemonics:</p>"},{"location":"Detailed_content/improvements/#basic-change","title":"Basic change","text":"<p>Means that there is a corresponding procedure in the Fortran 90 interface and only the following three changes have been made:</p> <ul> <li>change of the name of the procedure, <code>nf95_</code> instead of <code>nf90_</code>;</li> <li>subroutine instead of function;</li> <li>additional optional argument <code>ncerr</code> for error status.</li> </ul> <p>Thus, for example:</p> <pre><code>function nf90_inq_varid(ncid, name, varid)\n         integer, intent(in) :: ncid\n         character (len = *), intent( in) :: name\n         integer, intent(out) :: varid\n         integer :: nf90_inq_varid\n</code></pre> <p>becomes:</p> <pre><code>subroutine nf95_inq_varid(ncid, name, varid, ncerr)\n         integer, intent(in) :: ncid\n         character (len = *), intent( in) :: name\n         integer, intent(out) :: varid\n         integer, intent(out), optional:: ncerr\n</code></pre> <p>Procedures with basic change: <code>nf95_copy_att</code>, <code>nf95_put_att.f90</code>, <code>nf95_close</code>, <code>nf95_create</code>, <code>nf95_enddef</code>, <code>nf95_inquire</code>, <code>nf95_open</code>, <code>nf95_redef</code>, <code>nf95_sync</code>, <code>nf95_inq_grp_full_ncid</code>, <code>nf95_inq_dimid</code>, <code>nf95_inq_varid</code>, <code>nf95_inq_grp_parent</code></p> <p>If you call a NetCDF95 procedure with the optional argument ncerr, you can test the resulting value of ncerr against the constant <code>nf95_noerr</code>, in the module netcdf95.</p>"},{"location":"Detailed_content/improvements/#interface-change","title":"Interface change","text":"<p>Means that there is a corresponding procedure in the Fortran 90 interface, and the interface of the procedure has been changed beyond the \u201cbasic\u201d change described above, but there is no change in functionality.</p> <p>Procedures with interface change: <code>nf95_def_dim</code>, <code>nf95_inquire_dimension</code>, <code>nf95_def_var</code> and <code>nf95_def_var_scalar</code>, <code>nf95_inquire_attribute</code>,</p>"},{"location":"Detailed_content/improvements/#functionality-change","title":"Functionality change","text":"<p>Means that there is a corresponding procedure in the Fortran 90 interface, the interface of the procedure has been changed and the functionality has also been improved.</p> <p>Procedures with functionality change: <code>nf95_get_att</code>, <code>nf95_get_var</code>, <code>nf95_inquire_variable</code>, <code>nf95_inq_grpname</code>, <code>nf95_inq_grpname_full</code>, <code>nf95_inq_grps</code>, <code>nf95_inq_libvers</code>, <code>nf95_put_var</code></p>"},{"location":"Detailed_content/improvements/#additional-procedure","title":"Additional procedure","text":"<p>Means there is no corresponding procedure in the Fortran 90 interface.</p> <p>Additional procedures: <code>nf95_gw_var</code>, <code>nf95_find_coord</code>, <code>nf95_get_missing</code>, <code>nf95_create_single</code>, <code>nf95_inq_file_ncid</code>, <code>nf95_abort</code>, <code>nf95_inq_varnatts</code></p>"},{"location":"Detailed_content/variables/","title":"Variables","text":"<p>This page describles procedures handling NetCDF variables.</p> <p>See the improvements page for an explanation of the mnemonics \u201cbasic change\u201d, \u201cinterface change\u201d, \u201cfunctionality change\u201d, \u201cadditional procedure\u201d.</p>"},{"location":"Detailed_content/variables/#reminder-on-allocatable-arguments","title":"Reminder on allocatable arguments","text":"<p>Some NetCDF95 procedures below have a dummy argument with attributes allocatable and <code>intent(out)</code>. Recall that in this case the associated actual argument must also have the allocatable attribute. If it is allocated before the call, it will automatically be deallocated and reallocated in the NetCDF95 procedure.</p>"},{"location":"Detailed_content/variables/#nf95_def_var-and-nf95_def_var_scalar","title":"<code>nf95_def_var</code> and <code>nf95_def_var_scalar</code>","text":"<p>(interface change)</p> <pre><code>subroutine nf95_def_var_scalar(ncid, name, xtype, varid, ncerr)\n  integer,               intent( in) :: ncid\n  character (len = *),   intent( in) :: name\n  integer,               intent( in) :: xtype\n  integer,               intent(out) :: varid\n integer, intent(out), optional:: ncerr\n</code></pre> <pre><code>subroutine nf95_def_var(ncid, name, xtype, dimids, varid, ncerr)\n  integer,               intent( in) :: ncid\n  character (len = *),   intent( in) :: name\n  integer,               intent( in) :: xtype\n  integer[, dimension(:)], intent( in) :: dimids\n  integer,               intent(out) :: varid\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>(<code>dimids</code> may be either a scalar or a rank 1 array.)</p> <p>Because of the additional optional argument <code>ncerr</code>, the generic procedure name <code>nf95_def_var</code> cannot include the case of a scalar variable. So there is a specific public procedure <code>nf95_def_var_scalar</code> for this case.</p> <p>Reference: <code>nf90_def_var</code></p>"},{"location":"Detailed_content/variables/#nf95_get_var","title":"<code>nf95_get_var</code>","text":"<p>(functionality change)</p> <pre><code>subroutine nf95_get_var(ncid, varid, values, start, &amp;\n     new_missing, ncerr)\n\n  integer, intent(in) :: ncid, varid\n  any type, intent(out):: values\n  integer, dimension(:), optional, intent(in):: start\n  same type as values, optional, intent(in):: new_missing\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>(if argument <code>values</code> is a scalar then arguments <code>count_nc</code>, stride and map must not be present)</p> <p>or</p> <pre><code>subroutine nf95_get_var(ncid, varid, values, start, &amp;\n     count_nc, stride, map, new_missing, ncerr)\n\n  integer, intent(in) :: ncid, varid\n  any type and any rank &gt;= 1, intent(out):: values\n  integer, dimension(:), optional, intent(in):: start, count_nc, stride, map\n  same type as values, optional, intent(in):: new_missing\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>(if argument <code>values</code> is an array then arguments <code>count_nc</code>, stride and map may be present)</p> <p>The argument for the number of indices selected along each dimension is called <code>count_nc</code> in <code>nf95_get_var</code>, instead of <code>count</code> in <code>nf90_get_var</code>. <code>count</code> is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure.</p> <p><code>nf95_get_var</code> checks that :</p> <ul> <li>the size of arguments <code>start</code> and <code>count_nc</code> equals the rank of the     NetCDF variable ;</li> <li>if <code>count_nc</code> is absent, the rank of argument <code>values</code> is lower than     or equal to the rank of the NetCDF variable.</li> </ul> <p>There is an optional argument, <code>new_missing</code>, which is not in the Fortran 90 NetCDF interface. If the argument <code>new_missing</code> is present then, in the returned <code>values</code>, the missing value from the NetCDF variable is replaced by <code>new_missing</code>.  This may be useful for example if, in your program, you need the missing value to be <code>ieee_value(0., IEEE_QUIET_NAN)</code> rather than <code>NF90_FILL_REAL</code>.</p> <p>Reference: <code>nf90_get_var</code></p>"},{"location":"Detailed_content/variables/#nf95_gunp_var","title":"<code>nf95_gunp_var</code>","text":"<p>(additional procedure)</p> <pre><code>subroutine nf95_gunp_var(ncid, varid, values, was_packed, start, count_nc, new_missing)\n  integer, intent(in):: ncid, varid\n  real or double precision, intent(out):: values(:, :, :)\n  logical, optional, intent(out):: was_packed\n  integer, optional, intent(in):: start(:), count_nc(:)\n  real or double precision, optional, intent(in):: new_missing\n</code></pre> <p><code>nf95_gunp_var</code> stands for \u201cNetCDF95 get unpacked variable\u201d. This procedure looks for attributes <code>scale_factor</code> or <code>add_offset</code> for the variable with given varid. If any of these attributes is found then <code>nf95_gunp_var</code> reads and unpacks the variable, else it has the same result as <code>nf95_get_var</code>. If the attributes <code>scale_factor</code> and <code>add_offset</code> are absent then the cost of <code>nf95_gunp_var</code> compared to <code>nf95_get_var</code> is just the cost of checking the presence of these attributes.</p> <p>Note that unpacked values can only be real or double precision.</p> <p>If the packed variable has missing values then you can choose a missing value for the unpacked variable. If you do not specify the <code>new_missing</code> argument then the default missing value, <code>nf95_fill_real</code> or <code>nf95_fill_double</code>, will be used.</p> <p>If you need to check missing values, in an application which can process both packed and unpacked variables, and if you do not use argument <code>new_missing</code>, then use argument <code>was_packed</code>. If <code>was_packed</code> is true then the missing value is <code>nf95_fill_real</code> or <code>nf95_fill_double</code>, else you need to find out what the missing value is by calling <code>nf95_get_missing</code>.</p>"},{"location":"Detailed_content/variables/#nf95_gw_var","title":"<code>nf95_gw_var</code>","text":"<p>(additional procedure)</p> <pre><code>  subroutine nf95_gw_var(ncid, varid, values)\n    integer, intent(in):: ncid\n    integer, intent(in):: varid\n    any type and kind, any rank, allocatable, intent(out):: values\n</code></pre> <p><code>nf95_gw_var</code> stands for \u201cNetCDF95 get whole variable\u201d. This procedure reads a whole NetCDF variable into an array. When you want all the values of the NetCDF variable, this procedure is a shortcut to: inquiring about the dimension IDs of the variable, inquiring about the length of each dimension found, allocating the Fortran variable, reading the values from the NetCDF variable.</p> <p>The procedure checks that the rank of the argument <code>values</code> equals the rank of the NetCDF variable. The procedure does not require nor check that the type of <code>values</code> corresponds to the type of the NetCDF variable: conversion will occur if necessary.</p> <p>See reminder on allocatable arguments.</p>"},{"location":"Detailed_content/variables/#nf95_inq_varid","title":"<code>nf95_inq_varid</code>","text":"<p>(basic change)</p> <pre><code>  subroutine nf95_inq_varid(ncid, name, varid, ncerr)\n    integer,             intent(in) :: ncid\n    character (len = *), intent(in) :: name\n    integer,             intent(out) :: varid\n    integer, intent(out), optional:: ncerr\n</code></pre> <p>Reference: <code>nf90_inq_varid</code></p>"},{"location":"Detailed_content/variables/#nf95_inq_varnatts","title":"<code>nf95_inq_varnatts</code>","text":"<p>(additional procedure)</p> <pre><code> subroutine nf95_inq_varnatts(ncid, varid, natts, ncerr)\n   integer, intent(in):: ncid, varid\n   integer, intent(out):: natts\n   integer, intent(out), optional:: ncerr\n</code></pre> <p>This procedure tells you how many attributes a variable has, knowing the variable ID. You can call it with <code>varid = nf95_global</code> to find out the number of global attributes.</p> <p>Strangely, although a procedure <code>nf90_inq_varnatts</code> is mentioned in the documentation of <code>nf90_inquire_attribute</code> and <code>nf90_inq_attname</code>, this procedure does not exist in the Fortran 90 NetCDF interface. So it seems the only way to get the number of attributes with the Fortran 90 NetCDF interface was to loop on <code>nf90_inq_attname</code> until it returned an error.</p> <p>Reference: <code>nc_inq_varnatts</code></p>"},{"location":"Detailed_content/variables/#nf95_inquire_variable","title":"<code>nf95_inquire_variable</code>","text":"<p>(functionality change)</p> <pre><code>  subroutine nf95_inquire_variable(ncid, varid, name, xtype, ndims, dimids, &amp;\n       nAtts, ncerr)\n    integer, intent(in):: ncid, varid\n    character(len = *), optional, intent(out):: name\n    integer, optional, intent(out) :: xtype, ndims\n    integer, dimension(:), optional, allocatable, intent(out) :: dimids\n    integer, optional, intent(out) :: nAtts\n    integer, intent(out), optional :: ncerr\n</code></pre> <p>In the \u201cnew\u201d <code>nf95_inquire_variable</code>, the argument <code>dimids</code> has the allocatable attribute. The procedure <code>nf95_inquire_variable</code> allocates and defines <code>dimids</code> if the argument is present. <code>dimids</code> is defined as a zero-sized array if the NetCDF variable is a scalar with no dimension.</p> <p>In the \u201cold\u201d <code>nf90_inquire_variable</code>, <code>dimids</code> was an assumed-size array. This was Fortran 77 style, not optimal. You had to allocate <code>dimids</code> in the calling procedure with a maximum possible number of dimensions. You also needed to call <code>nf90_inquire_variable</code> with the argument <code>ndims</code> present, to tell you which part of <code>dimids</code> was defined.</p> <p>See reminder on allocatable arguments.</p> <p>Reference: <code>nf90_inquire_variable</code></p>"},{"location":"Detailed_content/variables/#nf95_put_var","title":"<code>nf95_put_var</code>","text":"<p>(functionality change)</p> <pre><code>subroutine nf95_put_var(ncid, varid, values, start, ncerr)\n  integer,                         intent(in) :: ncid, varid\n  any type and any kind, intent(in) :: values\n  integer, dimension(:), optional, intent(in) :: start\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>(If argument <code>values</code> is a scalar then arguments <code>count_nc</code>, stride and map must not be present.)</p> <p>Or:</p> <pre><code>subroutine nf95_put_var(ncid, varid, values, start, count_nc, stride, map, ncerr)\n  integer,                         intent(in) :: ncid, varid\n  any type and any kind, any rank &gt;= 1, intent(in) :: values\n  integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map\n  integer, intent(out), optional:: ncerr\n</code></pre> <p>(If argument <code>values</code> is an array then arguments <code>count_nc</code>, stride and map may be present.)</p> <p>The argument for the number of indices selected along each dimension is called <code>count_nc</code> in <code>nf95_put_var</code>, instead of <code>count</code> in <code>nf90_put_var</code>. <code>count</code> is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure.</p> <p><code>nf95_put_var</code> checks that :</p> <ul> <li>the size of arguments <code>start</code> and <code>count_nc</code> equals the rank of the     NetCDF variable ;</li> <li>if <code>count_nc</code> is absent, the rank of argument <code>values</code> is lower than     or equal to the rank of the NetCDF variable.</li> </ul> <p>Reference: <code>nf90_put_var</code></p>"},{"location":"Detailed_content/version/","title":"Library version","text":"<p>(functionality change)</p> <pre><code>subroutine nf95_inq_libvers\n</code></pre> <p>The corresponding function <code>nf90_inq_libvers</code> in the Fortran 90 NetCDF interface surprisingly returns the version of the linked C library. <code>nf95_inq_libvers</code> is a subroutine, not a function, and it prints both the version of NetCDF95 and the version of the linked C library.</p>"}]}