{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction What is it? NetCDF95 is an alternative Fortran interface to the NetCDF library. The official Fortran interface is the Fortran 90 NetCDF interface . The name NetCDF95 was at first a reference to the Fortran 95 standard but NetCDF95 now uses Fortran 2003 features. Author: Lionel GUEZ Why an alternative interface? Compared to the the Fortran 90 NetCDF interface , NetCDF95 is meant to be friendlier and more secure. Notably: NetCDF95 frees you of the cumbersome task of handling the error status. NetCDF95 procedures behave like the Fortran input/output statements. That is, the error status is an optional output argument. Consider, for example, the Fortran formatted read statement: read([unit=]u, [fmt=]fmt [,iostat=ios] [, err=error-label] & [,end=end-label]) [list] If the err , end and iostat keywords are not provided, and there is a problem in the execution of the read statement, then execution of the program stops (with an informative error message from the compiler). Similarly, NetCDF95 procedures have an optional argument for error status. If the optional argument is absent and there is an error, then the NetCDF95 procedure produces an error message and stops the program. (The official Fortran 90 interface looks like it has been made to mimic the C interface, and this is not optimal in Fortran.) NetCDF95 frees you of assumptions on the size of arrays and the size of character strings when you call several inquiry procedures. (It does so by making use of allocatable arguments, a Fortran 2003 feature.) See nf95_inquire_variable , nf95_inq_grpname , nf95_inq_grps , nf95_inq_grpname_full . NetCDF95 offers procedures that have no counterpart in the official interface. These combine several calls to other NetCDF95 procedures for common higher-level tasks. See nf95_gw_var , nf95_find_coord , nf95_create_single , nf95_get_missing . NetCDF95 replaces functions by subroutines. Procedures of the official Fortran 90 interface are all functions, and they are all with side effects. First, they have intent(out) arguments. Furthermore, there is obviously data transfer inside the procedures. Any data transfer inside a function is considered as a side effect. In this respect, the Fortran 90 interface mimics the C interface. But Fortran has a different programming style than C and frowns upon side-effects in functions. See for example Metcalf and Reid (Fortran 90/95 Explained, 1999, \u00a7\u00a7 5.10 and 6.10). There are other improvements such as securing the call to nf95_get_var by checking the arguments start and count_nc , and renaming badly chosen argument names len and count to nclen and count_nc .","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-it","text":"NetCDF95 is an alternative Fortran interface to the NetCDF library. The official Fortran interface is the Fortran 90 NetCDF interface . The name NetCDF95 was at first a reference to the Fortran 95 standard but NetCDF95 now uses Fortran 2003 features. Author: Lionel GUEZ","title":"What is it?"},{"location":"#why-an-alternative-interface","text":"Compared to the the Fortran 90 NetCDF interface , NetCDF95 is meant to be friendlier and more secure. Notably: NetCDF95 frees you of the cumbersome task of handling the error status. NetCDF95 procedures behave like the Fortran input/output statements. That is, the error status is an optional output argument. Consider, for example, the Fortran formatted read statement: read([unit=]u, [fmt=]fmt [,iostat=ios] [, err=error-label] & [,end=end-label]) [list] If the err , end and iostat keywords are not provided, and there is a problem in the execution of the read statement, then execution of the program stops (with an informative error message from the compiler). Similarly, NetCDF95 procedures have an optional argument for error status. If the optional argument is absent and there is an error, then the NetCDF95 procedure produces an error message and stops the program. (The official Fortran 90 interface looks like it has been made to mimic the C interface, and this is not optimal in Fortran.) NetCDF95 frees you of assumptions on the size of arrays and the size of character strings when you call several inquiry procedures. (It does so by making use of allocatable arguments, a Fortran 2003 feature.) See nf95_inquire_variable , nf95_inq_grpname , nf95_inq_grps , nf95_inq_grpname_full . NetCDF95 offers procedures that have no counterpart in the official interface. These combine several calls to other NetCDF95 procedures for common higher-level tasks. See nf95_gw_var , nf95_find_coord , nf95_create_single , nf95_get_missing . NetCDF95 replaces functions by subroutines. Procedures of the official Fortran 90 interface are all functions, and they are all with side effects. First, they have intent(out) arguments. Furthermore, there is obviously data transfer inside the procedures. Any data transfer inside a function is considered as a side effect. In this respect, the Fortran 90 interface mimics the C interface. But Fortran has a different programming style than C and frowns upon side-effects in functions. See for example Metcalf and Reid (Fortran 90/95 Explained, 1999, \u00a7\u00a7 5.10 and 6.10). There are other improvements such as securing the call to nf95_get_var by checking the arguments start and count_nc , and renaming badly chosen argument names len and count to nclen and count_nc .","title":"Why an alternative interface?"},{"location":"changes/","text":"Changes before version control (See Github page for more recent changes.) October 12th, 2017. NetCDF95 is now in Fortran 2003. Uses allocatable dummy arguments. The actual argument of nf95_gw_var corresponding to dummy argument dimids must now be allocatable and not pointer. The actual argument of nf95_inquire_variable corresponding to dummy argument value must now be allocatable and not pointer. find_coord accepts \"plev\" as standard name. Added specific procedure nf95_get_var_2D_FourByteInt to generic nf95_get_var and specific nf95_gw_var_int_2d to generic nf95_gw_var . October 10th, 2014. Added nf95_sync . Added specific procedure in nf95_put_var . nf95_get_var and nf95_put_var now check that : the size of arguments start and count_nc equals the rank of the NetCDF variable ; if count_nc is absent, the rank of argument values is lower than or equal to the rank of the NetCDF variable. February 13th, 2013, added specific procedures in nf95_gw_var and nf95_put_att . March 22nd, 2012, added nf95_inquire_attribute and nf95_inquire . Fixed nf95_get_att : does not exit if argument ncerr is present and there is an error picked by nf90_inquire_attribute . January 24th, 2012, added specific procedures in nf95_get_var and nf95_gw_var . November 3rd, 2010, added nf95_get_var .","title":"Changes"},{"location":"changes/#changes-before-version-control","text":"(See Github page for more recent changes.) October 12th, 2017. NetCDF95 is now in Fortran 2003. Uses allocatable dummy arguments. The actual argument of nf95_gw_var corresponding to dummy argument dimids must now be allocatable and not pointer. The actual argument of nf95_inquire_variable corresponding to dummy argument value must now be allocatable and not pointer. find_coord accepts \"plev\" as standard name. Added specific procedure nf95_get_var_2D_FourByteInt to generic nf95_get_var and specific nf95_gw_var_int_2d to generic nf95_gw_var . October 10th, 2014. Added nf95_sync . Added specific procedure in nf95_put_var . nf95_get_var and nf95_put_var now check that : the size of arguments start and count_nc equals the rank of the NetCDF variable ; if count_nc is absent, the rank of argument values is lower than or equal to the rank of the NetCDF variable. February 13th, 2013, added specific procedures in nf95_gw_var and nf95_put_att . March 22nd, 2012, added nf95_inquire_attribute and nf95_inquire . Fixed nf95_get_att : does not exit if argument ncerr is present and there is an error picked by nf90_inquire_attribute . January 24th, 2012, added specific procedures in nf95_get_var and nf95_gw_var . November 3rd, 2010, added nf95_get_var .","title":"Changes before version control"},{"location":"installation/","text":"Installation Dependencies CMake (version \u2265 3.16) 1 . The NetCDF C library . The NetCDF-Fortran library . The Fortran compiler that was used to compile your installed NetCDF-Fortran library. Git (optional, the easiest way to download NetCDF95). Under Ubuntu \u2265 20.04 or Linux Mint \u2265 20, you can install all these dependencies with the following command: sudo apt install libnetcdff-dev gfortran cmake git Instructions Get NetCDF95 from Github . As the Git repository contains a submodule, the easiest way is to type: git clone --recurse-submodules https://github.com/lguez/NetCDF95.git If you prefer to download a ZIP file then you will also have to download the cmake subdirectory . Create a build subdirectory in the NetCDF95 directory you have just downloaded: cd NetCDF95 mkdir build cd build Decide in which directory you want to install NetCDF95 after compilation and type the command below with your choice after -DCMAKE_INSTALL_PREFIX= (enter an absolute path). For example: cmake .. -DCMAKE_INSTALL_PREFIX=~/.local Type: make install You do not need to keep the downloaded directory NetCDF95 (nor the build directory) after installation. Advanced instructions You can choose any name and any location for the build directory. You have to refer to the source directory when you run cmake from the build directory: mkdir /wherever/any/name cd /wherever/any/name cmake /where/I/downloaded/NetCDF95 -DCMAKE_INSTALL_PREFIX=~/.local NetCDF95 assumes that the Fortran default character kind is the same as the C character kind (the official NetCDF-Fortran interface makes the same assumption). You can test this by running the command ctest in the build directory. If this test fails then the procedures nf95_inq_grpname , nf95_inq_grpname_full and nf95_inq_grp_full_ncid are not reliable. You do not have to install. You can just use the compiled library in the build directory. So you do not have to specify the option -DCMAKE_INSTALL_PREFIX= and you can just type make instead of make install . You can compile with debugging options by adding the option -DCMAKE_BUILD_TYPE=Debug to the command cmake. Troubleshooting If your installation of NetCDF or NetCDF-Fortran is in a non-standard location, and CMake does not find it, then re-run cmake setting the variable CMAKE_PREFIX_PATH to the directory containing it. CMake will then search ${CMAKE_PREFIX_PATH}/lib , ${CMAKE_PREFIX_PATH}/include , etc. For example: cmake . -DCMAKE_PREFIX_PATH:PATH=/path/to/my/favorite/installation If you have several Fortran or C compilers on your machine, it is possible that CMake does not choose the ones you want. Note that when you run cmake, it prints lines telling which compilers it is going to use. For example : -- The Fortran compiler identification is GNU 11.3.0 -- The C compiler identification is GNU 11.3.0 So if you want other compilers, remove everything in the build directory and run cmake again setting the variables FC and CC to the compilers you want. For example: rm -r * # in the build directory! FC=ifort CC=icc cmake .. -DCMAKE_INSTALL_PREFIX=~/.local On Mac OS, after downloading the application from the CMake web site, run it, then click on \u201cHow to Install For Command Line Use\u201d in the Tools menu. \u21a9","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#dependencies","text":"CMake (version \u2265 3.16) 1 . The NetCDF C library . The NetCDF-Fortran library . The Fortran compiler that was used to compile your installed NetCDF-Fortran library. Git (optional, the easiest way to download NetCDF95). Under Ubuntu \u2265 20.04 or Linux Mint \u2265 20, you can install all these dependencies with the following command: sudo apt install libnetcdff-dev gfortran cmake git","title":"Dependencies"},{"location":"installation/#instructions","text":"Get NetCDF95 from Github . As the Git repository contains a submodule, the easiest way is to type: git clone --recurse-submodules https://github.com/lguez/NetCDF95.git If you prefer to download a ZIP file then you will also have to download the cmake subdirectory . Create a build subdirectory in the NetCDF95 directory you have just downloaded: cd NetCDF95 mkdir build cd build Decide in which directory you want to install NetCDF95 after compilation and type the command below with your choice after -DCMAKE_INSTALL_PREFIX= (enter an absolute path). For example: cmake .. -DCMAKE_INSTALL_PREFIX=~/.local Type: make install You do not need to keep the downloaded directory NetCDF95 (nor the build directory) after installation.","title":"Instructions"},{"location":"installation/#advanced-instructions","text":"You can choose any name and any location for the build directory. You have to refer to the source directory when you run cmake from the build directory: mkdir /wherever/any/name cd /wherever/any/name cmake /where/I/downloaded/NetCDF95 -DCMAKE_INSTALL_PREFIX=~/.local NetCDF95 assumes that the Fortran default character kind is the same as the C character kind (the official NetCDF-Fortran interface makes the same assumption). You can test this by running the command ctest in the build directory. If this test fails then the procedures nf95_inq_grpname , nf95_inq_grpname_full and nf95_inq_grp_full_ncid are not reliable. You do not have to install. You can just use the compiled library in the build directory. So you do not have to specify the option -DCMAKE_INSTALL_PREFIX= and you can just type make instead of make install . You can compile with debugging options by adding the option -DCMAKE_BUILD_TYPE=Debug to the command cmake.","title":"Advanced instructions"},{"location":"installation/#troubleshooting","text":"If your installation of NetCDF or NetCDF-Fortran is in a non-standard location, and CMake does not find it, then re-run cmake setting the variable CMAKE_PREFIX_PATH to the directory containing it. CMake will then search ${CMAKE_PREFIX_PATH}/lib , ${CMAKE_PREFIX_PATH}/include , etc. For example: cmake . -DCMAKE_PREFIX_PATH:PATH=/path/to/my/favorite/installation If you have several Fortran or C compilers on your machine, it is possible that CMake does not choose the ones you want. Note that when you run cmake, it prints lines telling which compilers it is going to use. For example : -- The Fortran compiler identification is GNU 11.3.0 -- The C compiler identification is GNU 11.3.0 So if you want other compilers, remove everything in the build directory and run cmake again setting the variables FC and CC to the compilers you want. For example: rm -r * # in the build directory! FC=ifort CC=icc cmake .. -DCMAKE_INSTALL_PREFIX=~/.local On Mac OS, after downloading the application from the CMake web site, run it, then click on \u201cHow to Install For Command Line Use\u201d in the Tools menu. \u21a9","title":"Troubleshooting"},{"location":"usage/","text":"Usage In the source code of the consumer program The name of the module that you must use in your Fortran program is netcdf95 . For example: use netcdf95, only: nf95_open, nf95_inq_varid, nf95_gw_var, nf95_close Building the consumer program with CMake If you build your program using NetCDF95 with CMake, then download both FindNetCDF_Fortran.cmake and FindnetCDF.cmake into the directory of your consumer program and add the following lines to the file CMakeLists.txt for your program: find_package(NetCDF_Fortran REQUIRED) find_package(NetCDF95 CONFIG REQUIRED) target_link_libraries(my_program PRIVATE NetCDF95::netcdf95 NetCDF_Fortran::netcdff) (replace my_program by the name of your target). Building the consumer program without CMake If you do not build the consumer program with CMake, take into account that your program will require netcdf95.mod (and possibly other .mod files produced by compilation of NetCDF95) at compile time and libnetcdf95.a at link time. Note that NetCDF95 uses the Fortran 90 NetCDF interface, so you must keep the options you would use for direct access to the Fortran 90 NetCDF interface. For most compilers, the options you will need to add are: -I$netcdf95_inc_dir at compile time and: -L$netcdf95_lib_dir -L$netcdf90_lib_dir -lnetcdf95 -lnetcdff -lnetcdf at link time, where $netcdf95_inc_dir is the directory where you put .mod files produced by compilation of NetCDF95, $netcdf95_lib_dir is the directory where you put libnetcdf95.a and $netcdf90_lib_dir is the directory where the Fortran 90 NetCDF interface is installed.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#in-the-source-code-of-the-consumer-program","text":"The name of the module that you must use in your Fortran program is netcdf95 . For example: use netcdf95, only: nf95_open, nf95_inq_varid, nf95_gw_var, nf95_close","title":"In the source code of the consumer program"},{"location":"usage/#building-the-consumer-program-with-cmake","text":"If you build your program using NetCDF95 with CMake, then download both FindNetCDF_Fortran.cmake and FindnetCDF.cmake into the directory of your consumer program and add the following lines to the file CMakeLists.txt for your program: find_package(NetCDF_Fortran REQUIRED) find_package(NetCDF95 CONFIG REQUIRED) target_link_libraries(my_program PRIVATE NetCDF95::netcdf95 NetCDF_Fortran::netcdff) (replace my_program by the name of your target).","title":"Building the consumer program with CMake"},{"location":"usage/#building-the-consumer-program-without-cmake","text":"If you do not build the consumer program with CMake, take into account that your program will require netcdf95.mod (and possibly other .mod files produced by compilation of NetCDF95) at compile time and libnetcdf95.a at link time. Note that NetCDF95 uses the Fortran 90 NetCDF interface, so you must keep the options you would use for direct access to the Fortran 90 NetCDF interface. For most compilers, the options you will need to add are: -I$netcdf95_inc_dir at compile time and: -L$netcdf95_lib_dir -L$netcdf90_lib_dir -lnetcdf95 -lnetcdff -lnetcdf at link time, where $netcdf95_inc_dir is the directory where you put .mod files produced by compilation of NetCDF95, $netcdf95_lib_dir is the directory where you put libnetcdf95.a and $netcdf90_lib_dir is the directory where the Fortran 90 NetCDF interface is installed.","title":"Building the consumer program without CMake"},{"location":"Detailed_content/attributes/","text":"Attributes This page describles procedures handling NetCDF attributes. See the improvements page for an explanation of the mnemonics \u201cbasic change\u201d, \u201cinterface change\u201d, \u201cfunctionality change\u201d, \u201cadditional procedure\u201d. nf95_copy_att (basic change) subroutine nf95_copy_att(ncid_in, varid_in, name, ncid_out, varid_out, ncerr) integer, intent( in):: ncid_in, varid_in character(len=*), intent( in):: name integer, intent( in):: ncid_out, varid_out integer, intent(out), optional:: ncerr Reference: nf90_copy_att nf95_get_att (functionality change) subroutine nf95_get_att(ncid, varid, name, values, ncerr) integer, intent( in) :: ncid, varid character(len = *), intent( in) :: name character(len = *), integer or real(any kind), intent(out) :: values integer, intent(out), optional:: ncerr nf95_get_att is more secure than nf90_get_att . For an argument values of type character , nf95_get_att checks that the values argument is long enough and removes the null terminator, if any. For a numeric scalar values argument, nf95_get_att checks that the attribute contains a single value. Reference: nf90_get_att nf95_get_missing (additional procedure) subroutine nf95_get_missing(ncid, varid, missing) integer, intent(in):: ncid, varid real or double precision or integer or character, intent(out):: missing ! missing or fill value Returns the missing_value attribute if present, else the _FillValue if present, else nf90_fill_real or nf90_fill_double . nf95_inquire_attribute (interface change) subroutine nf95_inquire_attribute(ncid, varid, name, xtype, nclen, attnum, & ncerr) integer, intent( in) :: ncid, varid character (len = *), intent( in) :: name integer, intent(out), optional :: xtype, nclen, attnum integer, intent(out), optional:: ncerr The argument for the number of values or characters of the attribute is called nclen in nf95_inquire_attribute , instead of len in nf90_inquire_attribute . len is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. Reference: nf90_inquire_attribute nf95_put_att (basic change) subroutine nf95_put_att(ncid, varid, name, values, ncerr) integer, intent(in) :: ncid, varid character(len = *), intent(in) :: name character(len = *) or integer(any kind) or real(any kind), intent(in) :: values integer, intent(out), optional:: ncerr Reference: nf90_put_att","title":"Attributes"},{"location":"Detailed_content/attributes/#attributes","text":"This page describles procedures handling NetCDF attributes. See the improvements page for an explanation of the mnemonics \u201cbasic change\u201d, \u201cinterface change\u201d, \u201cfunctionality change\u201d, \u201cadditional procedure\u201d.","title":"Attributes"},{"location":"Detailed_content/attributes/#nf95_copy_att","text":"(basic change) subroutine nf95_copy_att(ncid_in, varid_in, name, ncid_out, varid_out, ncerr) integer, intent( in):: ncid_in, varid_in character(len=*), intent( in):: name integer, intent( in):: ncid_out, varid_out integer, intent(out), optional:: ncerr Reference: nf90_copy_att","title":"nf95_copy_att"},{"location":"Detailed_content/attributes/#nf95_get_att","text":"(functionality change) subroutine nf95_get_att(ncid, varid, name, values, ncerr) integer, intent( in) :: ncid, varid character(len = *), intent( in) :: name character(len = *), integer or real(any kind), intent(out) :: values integer, intent(out), optional:: ncerr nf95_get_att is more secure than nf90_get_att . For an argument values of type character , nf95_get_att checks that the values argument is long enough and removes the null terminator, if any. For a numeric scalar values argument, nf95_get_att checks that the attribute contains a single value. Reference: nf90_get_att","title":"nf95_get_att"},{"location":"Detailed_content/attributes/#nf95_get_missing","text":"(additional procedure) subroutine nf95_get_missing(ncid, varid, missing) integer, intent(in):: ncid, varid real or double precision or integer or character, intent(out):: missing ! missing or fill value Returns the missing_value attribute if present, else the _FillValue if present, else nf90_fill_real or nf90_fill_double .","title":"nf95_get_missing"},{"location":"Detailed_content/attributes/#nf95_inquire_attribute","text":"(interface change) subroutine nf95_inquire_attribute(ncid, varid, name, xtype, nclen, attnum, & ncerr) integer, intent( in) :: ncid, varid character (len = *), intent( in) :: name integer, intent(out), optional :: xtype, nclen, attnum integer, intent(out), optional:: ncerr The argument for the number of values or characters of the attribute is called nclen in nf95_inquire_attribute , instead of len in nf90_inquire_attribute . len is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. Reference: nf90_inquire_attribute","title":"nf95_inquire_attribute"},{"location":"Detailed_content/attributes/#nf95_put_att","text":"(basic change) subroutine nf95_put_att(ncid, varid, name, values, ncerr) integer, intent(in) :: ncid, varid character(len = *), intent(in) :: name character(len = *) or integer(any kind) or real(any kind), intent(in) :: values integer, intent(out), optional:: ncerr Reference: nf90_put_att","title":"nf95_put_att"},{"location":"Detailed_content/datasets/","text":"Datasets & co This page describles procedures handling a whole dataset, or handling a combination of NetCDF variables and dimensions. See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\". nf95_close (basic change) subroutine nf95_close(ncid, ncerr) integer, intent( in) :: ncid integer, intent(out), optional :: ncerr Reference: nf90_close nf95_create (basic change) subroutine nf95_create(path, cmode, ncid, initialsize, chunksize, ncerr) character (len = *), intent(in ) :: path integer, intent(in ) :: cmode integer, intent( out) :: ncid integer, optional, intent(in ) :: initialsize integer, optional, intent(inout) :: chunksize integer, intent(out), optional :: ncerr Reference: nf90_create nf95_create_single (additional procedure) subroutine nf95_create_single(name, coordinates, ncid, varid, varid_coord) character(len = *), intent(in):: name type(coord_def), intent(in):: coordinates(:) integer, intent(out):: ncid, varid, varid_coord(:) This procedure is a shortcut to create a NetCDF file containing a single primary variable, with all its coordinates. The coordinates are specified using the derived type coord_def : type coord_def character(len = NF90_MAX_NAME) name integer nclen character(len = :), allocatable:: attr_name(:), attr_val(:) end type coord_def After the call to nf95_create_single , the NetCDF dataset is still in define mode, so you can add attributes if appropriate. nf95_enddef (basic change) subroutine nf95_enddef(ncid, h_minfree, v_align, v_minfree, r_align, ncerr) integer, intent( in) :: ncid integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align integer, intent(out), optional :: ncerr Reference: nf90_enddef nf95_find_coord (additional procedure) subroutine nf95_find_coord(ncid, name, dimid, varid, std_name) integer, intent(in):: ncid character(len=*), intent(out), optional:: name ! blanks if not found ! The actual character argument should normally have the length ! \"NF90_MAX_NAME\". integer, intent(out), optional:: dimid ! 0 if not found integer, intent(out), optional:: varid ! 0 if not found character(len=*), intent(in):: std_name ! standard name : \"plev\", \"latitude\", \"longitude\" or \"time\" This procedure returns the name, dimension id or variable id of the NetCDF coordinate with standard name std_name , if such a coordinate exists. The standard name is only used to know what to search, it is not used for the search itself. The search itself is done via a string match on the attribute \"units\". So the NetCDF variable one looks for does not need to have the attribute std_name . nf95_inquire (basic change) subroutine nf95_inquire(ncid, nDimensions, nVariables, nAttributes, & unlimitedDimId, formatNum, ncerr) integer, intent( in) :: ncid integer, optional, intent(out) :: nDimensions, nVariables, nAttributes integer, optional, intent(out) :: unlimitedDimId, formatNum integer, intent(out), optional:: ncerr Reference: nf90_inquire nf95_open (basic change) subroutine nf95_open(path, mode, ncid, chunksize, ncerr) character(len=*), intent(in):: path integer, intent(in):: mode integer, intent(out):: ncid integer, intent(inout), optional:: chunksize integer, intent(out), optional:: ncerr Reference: nf90_open nf95_redef (basic change) subroutine nf95_redef(ncid, ncerr) integer, intent( in) :: ncid integer, intent(out), optional :: ncerr Reference: nf90_redef nf95_sync (basic change) subroutine nf95_sync(ncid, ncerr) integer, intent( in) :: ncid integer, intent(out), optional :: ncerr","title":"Datasets & co"},{"location":"Detailed_content/datasets/#datasets-co","text":"This page describles procedures handling a whole dataset, or handling a combination of NetCDF variables and dimensions. See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\".","title":"Datasets &amp; co"},{"location":"Detailed_content/datasets/#nf95_close","text":"(basic change) subroutine nf95_close(ncid, ncerr) integer, intent( in) :: ncid integer, intent(out), optional :: ncerr Reference: nf90_close","title":"nf95_close"},{"location":"Detailed_content/datasets/#nf95_create","text":"(basic change) subroutine nf95_create(path, cmode, ncid, initialsize, chunksize, ncerr) character (len = *), intent(in ) :: path integer, intent(in ) :: cmode integer, intent( out) :: ncid integer, optional, intent(in ) :: initialsize integer, optional, intent(inout) :: chunksize integer, intent(out), optional :: ncerr Reference: nf90_create","title":"nf95_create"},{"location":"Detailed_content/datasets/#nf95_create_single","text":"(additional procedure) subroutine nf95_create_single(name, coordinates, ncid, varid, varid_coord) character(len = *), intent(in):: name type(coord_def), intent(in):: coordinates(:) integer, intent(out):: ncid, varid, varid_coord(:) This procedure is a shortcut to create a NetCDF file containing a single primary variable, with all its coordinates. The coordinates are specified using the derived type coord_def : type coord_def character(len = NF90_MAX_NAME) name integer nclen character(len = :), allocatable:: attr_name(:), attr_val(:) end type coord_def After the call to nf95_create_single , the NetCDF dataset is still in define mode, so you can add attributes if appropriate.","title":"nf95_create_single"},{"location":"Detailed_content/datasets/#nf95_enddef","text":"(basic change) subroutine nf95_enddef(ncid, h_minfree, v_align, v_minfree, r_align, ncerr) integer, intent( in) :: ncid integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align integer, intent(out), optional :: ncerr Reference: nf90_enddef","title":"nf95_enddef"},{"location":"Detailed_content/datasets/#nf95_find_coord","text":"(additional procedure) subroutine nf95_find_coord(ncid, name, dimid, varid, std_name) integer, intent(in):: ncid character(len=*), intent(out), optional:: name ! blanks if not found ! The actual character argument should normally have the length ! \"NF90_MAX_NAME\". integer, intent(out), optional:: dimid ! 0 if not found integer, intent(out), optional:: varid ! 0 if not found character(len=*), intent(in):: std_name ! standard name : \"plev\", \"latitude\", \"longitude\" or \"time\" This procedure returns the name, dimension id or variable id of the NetCDF coordinate with standard name std_name , if such a coordinate exists. The standard name is only used to know what to search, it is not used for the search itself. The search itself is done via a string match on the attribute \"units\". So the NetCDF variable one looks for does not need to have the attribute std_name .","title":"nf95_find_coord"},{"location":"Detailed_content/datasets/#nf95_inquire","text":"(basic change) subroutine nf95_inquire(ncid, nDimensions, nVariables, nAttributes, & unlimitedDimId, formatNum, ncerr) integer, intent( in) :: ncid integer, optional, intent(out) :: nDimensions, nVariables, nAttributes integer, optional, intent(out) :: unlimitedDimId, formatNum integer, intent(out), optional:: ncerr Reference: nf90_inquire","title":"nf95_inquire"},{"location":"Detailed_content/datasets/#nf95_open","text":"(basic change) subroutine nf95_open(path, mode, ncid, chunksize, ncerr) character(len=*), intent(in):: path integer, intent(in):: mode integer, intent(out):: ncid integer, intent(inout), optional:: chunksize integer, intent(out), optional:: ncerr Reference: nf90_open","title":"nf95_open"},{"location":"Detailed_content/datasets/#nf95_redef","text":"(basic change) subroutine nf95_redef(ncid, ncerr) integer, intent( in) :: ncid integer, intent(out), optional :: ncerr Reference: nf90_redef","title":"nf95_redef"},{"location":"Detailed_content/datasets/#nf95_sync","text":"(basic change) subroutine nf95_sync(ncid, ncerr) integer, intent( in) :: ncid integer, intent(out), optional :: ncerr","title":"nf95_sync"},{"location":"Detailed_content/dimensions/","text":"Dimensions This page describles procedures handling NetCDF dimensions. See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\". nf95_def_dim (interface change) subroutine nf95_def_dim(ncid, name, nclen, dimid, ncerr) integer, intent( in) :: ncid character (len = *), intent( in) :: name integer, intent( in) :: nclen integer, intent(out) :: dimid integer, intent(out), optional :: ncerr The argument for the length of the dimension is called nclen in nf95_def_dim , instead of len in nf90_def_dim . len is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. Reference: nf90_def_dim nf95_inq_dimid (basic change) subroutine nf95_inq_dimid(ncid, name, dimid, ncerr) integer, intent(in) :: ncid character (len = *), intent(in) :: name integer, intent(out) :: dimid integer, intent(out), optional:: ncerr Reference: nf90_inq_dimid nf95_inquire_dimension (interface change) subroutine nf95_inquire_dimension(ncid, dimid, name, nclen, ncerr) integer, intent( in) :: ncid, dimid character (len = *), optional, intent(out) :: name integer, optional, intent(out) :: nclen integer, intent(out), optional:: ncerr The argument for the length of the dimension is called nclen in nf95_inquire_dimension , instead of len in nf90_inquire_dimension . len is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. Reference: nf90_inquire_dimension","title":"Dimensions"},{"location":"Detailed_content/dimensions/#dimensions","text":"This page describles procedures handling NetCDF dimensions. See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\".","title":"Dimensions"},{"location":"Detailed_content/dimensions/#nf95_def_dim","text":"(interface change) subroutine nf95_def_dim(ncid, name, nclen, dimid, ncerr) integer, intent( in) :: ncid character (len = *), intent( in) :: name integer, intent( in) :: nclen integer, intent(out) :: dimid integer, intent(out), optional :: ncerr The argument for the length of the dimension is called nclen in nf95_def_dim , instead of len in nf90_def_dim . len is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. Reference: nf90_def_dim","title":"nf95_def_dim"},{"location":"Detailed_content/dimensions/#nf95_inq_dimid","text":"(basic change) subroutine nf95_inq_dimid(ncid, name, dimid, ncerr) integer, intent(in) :: ncid character (len = *), intent(in) :: name integer, intent(out) :: dimid integer, intent(out), optional:: ncerr Reference: nf90_inq_dimid","title":"nf95_inq_dimid"},{"location":"Detailed_content/dimensions/#nf95_inquire_dimension","text":"(interface change) subroutine nf95_inquire_dimension(ncid, dimid, name, nclen, ncerr) integer, intent( in) :: ncid, dimid character (len = *), optional, intent(out) :: name integer, optional, intent(out) :: nclen integer, intent(out), optional:: ncerr The argument for the length of the dimension is called nclen in nf95_inquire_dimension , instead of len in nf90_inquire_dimension . len is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. Reference: nf90_inquire_dimension","title":"nf95_inquire_dimension"},{"location":"Detailed_content/errors/","text":"Handling of errors If you call a NetCDF95 procedure without the optional ncerr argument, and some error occurs, then the NetCDF95 procedure will: write to standard output all the information it has, including the string produced by nf90_strerror ; try to close the NetCDF file; stop the program, with an exit status of 1. For example, if some error occurs within a call to nf95_inq_varid , nf95_inq_varid will write to standard output: nf95_inq_varid, name = < name of the variable you inquired about >: < string produced by nf90_strerror > nf95_abort (additional procedure) subroutine nf95_abort(message, ncerr, ncid, varid) character(len=*), intent(in):: message ! (should include name of calling procedure) integer, intent(in):: ncerr integer, intent(in), optional :: ncid ! This can be the file ncid or a group ncid. Provide this argument ! if you want nf95_abort to try to close the file. integer, intent(in), optional :: varid This is a public procedure which is also used internally in NetCDF95. nf95_abort prints a message and stops the program. nf95_abort may also be useful after calling procedures of the Fortran 90 interface that have not been implemented in NetCDF95. You should include the name of the calling procedure in the message argument. Provide the ncid argument if you want nf95_abort to try to close the file. Provide varid if you want nf95_abort to print it.","title":"Handling of errors"},{"location":"Detailed_content/errors/#handling-of-errors","text":"If you call a NetCDF95 procedure without the optional ncerr argument, and some error occurs, then the NetCDF95 procedure will: write to standard output all the information it has, including the string produced by nf90_strerror ; try to close the NetCDF file; stop the program, with an exit status of 1. For example, if some error occurs within a call to nf95_inq_varid , nf95_inq_varid will write to standard output: nf95_inq_varid, name = < name of the variable you inquired about >: < string produced by nf90_strerror >","title":"Handling of errors"},{"location":"Detailed_content/errors/#nf95_abort","text":"(additional procedure) subroutine nf95_abort(message, ncerr, ncid, varid) character(len=*), intent(in):: message ! (should include name of calling procedure) integer, intent(in):: ncerr integer, intent(in), optional :: ncid ! This can be the file ncid or a group ncid. Provide this argument ! if you want nf95_abort to try to close the file. integer, intent(in), optional :: varid This is a public procedure which is also used internally in NetCDF95. nf95_abort prints a message and stops the program. nf95_abort may also be useful after calling procedures of the Fortran 90 interface that have not been implemented in NetCDF95. You should include the name of the calling procedure in the message argument. Provide the ncid argument if you want nf95_abort to try to close the file. Provide varid if you want nf95_abort to print it.","title":"nf95_abort"},{"location":"Detailed_content/groups/","text":"Groups This page describles procedures handling NetCDF groups. See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\". nf95_inq_file_ncid (additional procedure) subroutine nf95_inq_file_ncid(ncid_file, grpid, ncerr) ! Find the ncid of the file (that is, the root group), knowing the ! ncid of a group in the file. integer, intent(out):: ncid_file integer, intent(in):: grpid integer, intent(out), optional:: ncerr nf95_inq_grp_full_ncid (basic change) subroutine nf95_inq_grp_full_ncid(ncid, full_name, grp_ncid, ncerr) integer, intent(in):: ncid ! can be the file id or a group id character(len = *), intent(in):: full_name ! Should be a path relative to ncid (which can correspond to the ! root group or a subgroup). Can be an immediate subgroup or a ! deeper subgroup. integer, intent(out):: grp_ncid integer, intent(out), optional:: ncerr You know the relative path of a group and you want its ncid. Reference: nc_inq_grp_full_ncid nf95_inq_grpname (functionality change) subroutine nf95_inq_grpname(ncid, name, ncerr) integer, intent(in):: ncid ! can be the file id or a group id character(len = :), allocatable, intent(out):: name ! without path integer, intent(out), optional:: ncerr You know the ncid of a group (which can be the root group) and you want the basename of this group. The basename of the group is the last part in the absolute path, as in the Unix basename program. The basename of the root group is \u201c/\u201d. The functionality change is that the argument name has dynamic, deferred length. The problem with the Fortran 90 interface: name has assumed length in the Fortran 90 interface. Also, there is no way in the Fortran 90 interface to only inquire about the length of the name. The function nf90_inq_grpname_len gives the length of the absolute path of the group, not the length of the basename of the group. Reference: nf90_inq_grpname nf95_inq_grpname_full (functionality change) subroutine nf95_inq_grpname_full(ncid, full_name, ncerr) integer, intent(in):: ncid character(len = :), allocatable, intent(out):: full_name ! absolute path integer, intent(out), optional:: ncerr You know the ncid of a group (which can be the root group) and you want the absolute path of the group. The functionality change is that the argument full_name has dynamic, deferred length, and there is no length argument. Since full_name is allocated to the exact length of the path, the length argument is useless, you can just query the length of the actual argument after the call. The problem with the Fortran 90 interface: the name argument has assumed length in the Fortran 90 interface. You have to call nf90_inq_grpname_len first to know the length of the actual argument that you will associate to name. Reference: nf90_inq_grpname_full nf95_inq_grp_parent (basic change) subroutine nf95_inq_grp_parent(ncid, parent_ncid, ncerr) integer, intent(in):: ncid integer, intent(out):: parent_ncid integer, intent(out), optional:: ncerr You know the ncid of a group and you want the ncid of the parent group. nf95_inq_grps (functionality change) subroutine nf95_inq_grps(ncid, ncids, ncerr) integer, intent(in):: ncid ! can be the file id or a group id integer, allocatable, intent(out):: ncids(:) integer, intent(out), optional:: ncerr You know the ncid of a group (which can be the root group) and you want the ncids of its immediate subgroups. The functionality change is that the argument ncids is allocatable and there is no argument numgrps. Since ncids is allocated to the number of groups, the argument numgrps is useless, you can just query the size of the actual argument associated to ncids after the call. The problem with the Fortran 90 interface: ncids has assumed shape in the Fortran 90 interface. Also, there is no way in the Fortran 90 interface to only inquire about the number of subgroups. The Fortran 90 interface is dangerous here because it does not check that the size of ncids is large enough: a segmentation violation will occur if it is not. NetCDF95 solves this by going directly to the C interface. Reference: nf90_inq_grps and nc_inq_grps","title":"Groups"},{"location":"Detailed_content/groups/#groups","text":"This page describles procedures handling NetCDF groups. See the improvements page for an explanation of the mnemonics \"basic change\", \"interface change\", \"functionality change\", \"additional procedure\".","title":"Groups"},{"location":"Detailed_content/groups/#nf95_inq_file_ncid","text":"(additional procedure) subroutine nf95_inq_file_ncid(ncid_file, grpid, ncerr) ! Find the ncid of the file (that is, the root group), knowing the ! ncid of a group in the file. integer, intent(out):: ncid_file integer, intent(in):: grpid integer, intent(out), optional:: ncerr","title":"nf95_inq_file_ncid"},{"location":"Detailed_content/groups/#nf95_inq_grp_full_ncid","text":"(basic change) subroutine nf95_inq_grp_full_ncid(ncid, full_name, grp_ncid, ncerr) integer, intent(in):: ncid ! can be the file id or a group id character(len = *), intent(in):: full_name ! Should be a path relative to ncid (which can correspond to the ! root group or a subgroup). Can be an immediate subgroup or a ! deeper subgroup. integer, intent(out):: grp_ncid integer, intent(out), optional:: ncerr You know the relative path of a group and you want its ncid. Reference: nc_inq_grp_full_ncid","title":"nf95_inq_grp_full_ncid"},{"location":"Detailed_content/groups/#nf95_inq_grpname","text":"(functionality change) subroutine nf95_inq_grpname(ncid, name, ncerr) integer, intent(in):: ncid ! can be the file id or a group id character(len = :), allocatable, intent(out):: name ! without path integer, intent(out), optional:: ncerr You know the ncid of a group (which can be the root group) and you want the basename of this group. The basename of the group is the last part in the absolute path, as in the Unix basename program. The basename of the root group is \u201c/\u201d. The functionality change is that the argument name has dynamic, deferred length. The problem with the Fortran 90 interface: name has assumed length in the Fortran 90 interface. Also, there is no way in the Fortran 90 interface to only inquire about the length of the name. The function nf90_inq_grpname_len gives the length of the absolute path of the group, not the length of the basename of the group. Reference: nf90_inq_grpname","title":"nf95_inq_grpname"},{"location":"Detailed_content/groups/#nf95_inq_grpname_full","text":"(functionality change) subroutine nf95_inq_grpname_full(ncid, full_name, ncerr) integer, intent(in):: ncid character(len = :), allocatable, intent(out):: full_name ! absolute path integer, intent(out), optional:: ncerr You know the ncid of a group (which can be the root group) and you want the absolute path of the group. The functionality change is that the argument full_name has dynamic, deferred length, and there is no length argument. Since full_name is allocated to the exact length of the path, the length argument is useless, you can just query the length of the actual argument after the call. The problem with the Fortran 90 interface: the name argument has assumed length in the Fortran 90 interface. You have to call nf90_inq_grpname_len first to know the length of the actual argument that you will associate to name. Reference: nf90_inq_grpname_full","title":"nf95_inq_grpname_full"},{"location":"Detailed_content/groups/#nf95_inq_grp_parent","text":"(basic change) subroutine nf95_inq_grp_parent(ncid, parent_ncid, ncerr) integer, intent(in):: ncid integer, intent(out):: parent_ncid integer, intent(out), optional:: ncerr You know the ncid of a group and you want the ncid of the parent group.","title":"nf95_inq_grp_parent"},{"location":"Detailed_content/groups/#nf95_inq_grps","text":"(functionality change) subroutine nf95_inq_grps(ncid, ncids, ncerr) integer, intent(in):: ncid ! can be the file id or a group id integer, allocatable, intent(out):: ncids(:) integer, intent(out), optional:: ncerr You know the ncid of a group (which can be the root group) and you want the ncids of its immediate subgroups. The functionality change is that the argument ncids is allocatable and there is no argument numgrps. Since ncids is allocated to the number of groups, the argument numgrps is useless, you can just query the size of the actual argument associated to ncids after the call. The problem with the Fortran 90 interface: ncids has assumed shape in the Fortran 90 interface. Also, there is no way in the Fortran 90 interface to only inquire about the number of subgroups. The Fortran 90 interface is dangerous here because it does not check that the size of ncids is large enough: a segmentation violation will occur if it is not. NetCDF95 solves this by going directly to the C interface. Reference: nf90_inq_grps and nc_inq_grps","title":"nf95_inq_grps"},{"location":"Detailed_content/improvements/","text":"The four types of improvements In the following documentation, we give a description of the interface of each NetCDF95 procedure. We will label each NetCDF95 procedure with one of the following four (mutually exclusive) mnemonics: basic change Means that there is a corresponding procedure in the Fortran 90 interface and only the following three changes have been made: change of the name of the procedure, nf95_ instead of nf90_ ; subroutine instead of function; additional optional argument ncerr for error status. Thus, for example: function nf90_inq_varid(ncid, name, varid) integer, intent(in) :: ncid character (len = *), intent( in) :: name integer, intent(out) :: varid integer :: nf90_inq_varid becomes: subroutine nf95_inq_varid(ncid, name, varid, ncerr) integer, intent(in) :: ncid character (len = *), intent( in) :: name integer, intent(out) :: varid integer, intent(out), optional:: ncerr Procedures with basic change: nf95_copy_att , nf95_put_att.f90 , nf95_close , nf95_create , nf95_enddef , nf95_inquire , nf95_open , nf95_redef , nf95_sync , nf95_inq_grp_full_ncid , nf95_inq_dimid , nf95_inq_varid , nf95_inq_grp_parent If you call a NetCDF95 procedure with the optional argument ncerr, you can test the resulting value of ncerr against the constant nf95_noerr , in the module netcdf95. interface change Means that there is a corresponding procedure in the Fortran 90 interface, and the interface of the procedure has been changed beyond the \u201cbasic\u201d change described above, but there is no change in functionality. Procedures with interface change: nf95_def_dim , nf95_inquire_dimension , nf95_def_var and nf95_def_var_scalar , nf95_inquire_attribute , nf95_inq_grpname , nf95_inq_grpname_full , nf95_inq_grps functionality change Means that there is a corresponding procedure in the Fortran 90 interface, the interface of the procedure has been changed and the functionality has also been improved. Procedures with functionality change: nf95_get_var , nf95_inquire_variable , nf95_put_var , nf95_get_att additional procedure Means there is no corresponding procedure in the Fortran 90 interface. Additional procedures: nf95_gw_var , nf95_find_coord , nf95_get_missing , nf95_create_single , nf95_inq_file_ncid , nf95_abort","title":"The four types of improvements"},{"location":"Detailed_content/improvements/#the-four-types-of-improvements","text":"In the following documentation, we give a description of the interface of each NetCDF95 procedure. We will label each NetCDF95 procedure with one of the following four (mutually exclusive) mnemonics: basic change Means that there is a corresponding procedure in the Fortran 90 interface and only the following three changes have been made: change of the name of the procedure, nf95_ instead of nf90_ ; subroutine instead of function; additional optional argument ncerr for error status. Thus, for example: function nf90_inq_varid(ncid, name, varid) integer, intent(in) :: ncid character (len = *), intent( in) :: name integer, intent(out) :: varid integer :: nf90_inq_varid becomes: subroutine nf95_inq_varid(ncid, name, varid, ncerr) integer, intent(in) :: ncid character (len = *), intent( in) :: name integer, intent(out) :: varid integer, intent(out), optional:: ncerr Procedures with basic change: nf95_copy_att , nf95_put_att.f90 , nf95_close , nf95_create , nf95_enddef , nf95_inquire , nf95_open , nf95_redef , nf95_sync , nf95_inq_grp_full_ncid , nf95_inq_dimid , nf95_inq_varid , nf95_inq_grp_parent If you call a NetCDF95 procedure with the optional argument ncerr, you can test the resulting value of ncerr against the constant nf95_noerr , in the module netcdf95. interface change Means that there is a corresponding procedure in the Fortran 90 interface, and the interface of the procedure has been changed beyond the \u201cbasic\u201d change described above, but there is no change in functionality. Procedures with interface change: nf95_def_dim , nf95_inquire_dimension , nf95_def_var and nf95_def_var_scalar , nf95_inquire_attribute , nf95_inq_grpname , nf95_inq_grpname_full , nf95_inq_grps functionality change Means that there is a corresponding procedure in the Fortran 90 interface, the interface of the procedure has been changed and the functionality has also been improved. Procedures with functionality change: nf95_get_var , nf95_inquire_variable , nf95_put_var , nf95_get_att additional procedure Means there is no corresponding procedure in the Fortran 90 interface. Additional procedures: nf95_gw_var , nf95_find_coord , nf95_get_missing , nf95_create_single , nf95_inq_file_ncid , nf95_abort","title":"The four types of improvements"},{"location":"Detailed_content/variables/","text":"Variables This page describles procedures handling NetCDF variables. See the improvements page for an explanation of the mnemonics \u201cbasic change\u201d, \u201cinterface change\u201d, \u201cfunctionality change\u201d, \u201cadditional procedure\u201d. Reminder on allocatable arguments Some NetCDF95 procedures below have a dummy argument with attributes allocatable and intent(out) . Recall that in this case the associated actual argument must also have the allocatable attribute. If it is allocated before the call, it will automatically be deallocated and reallocated in the NetCDF95 procedure. nf95_def_var and nf95_def_var_scalar (interface change) subroutine nf95_def_var_scalar(ncid, name, xtype, varid, ncerr) integer, intent( in) :: ncid character (len = *), intent( in) :: name integer, intent( in) :: xtype integer, intent(out) :: varid integer, intent(out), optional:: ncerr subroutine nf95_def_var(ncid, name, xtype, dimids, varid, ncerr) integer, intent( in) :: ncid character (len = *), intent( in) :: name integer, intent( in) :: xtype integer[, dimension(:)], intent( in) :: dimids integer, intent(out) :: varid integer, intent(out), optional:: ncerr ( dimids may be either a scalar or a rank 1 array.) Because of the additional optional argument ncerr , the generic procedure name nf95_def_var cannot include the case of a scalar variable. So there is a specific public procedure nf95_def_var_scalar for this case. Reference: nf90_def_var nf95_get_var (functionality change) subroutine nf95_get_var(ncid, varid, values, start, & new_missing, ncerr) integer, intent(in) :: ncid, varid any type, intent(out):: values integer, dimension(:), optional, intent(in):: start same type as values, optional, intent(in):: new_missing integer, intent(out), optional:: ncerr (if argument values is a scalar then arguments count_nc , stride and map must not be present) or subroutine nf95_get_var(ncid, varid, values, start, & count_nc, stride, map, new_missing, ncerr) integer, intent(in) :: ncid, varid any type and any rank >= 1, intent(out):: values integer, dimension(:), optional, intent(in):: start, count_nc, stride, map same type as values, optional, intent(in):: new_missing integer, intent(out), optional:: ncerr (if argument values is an array then arguments count_nc , stride and map may be present) The argument for the number of indices selected along each dimension is called count_nc in nf95_get_var , instead of count in nf90_get_var . count is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. nf95_get_var checks that : the size of arguments start and count_nc equals the rank of the NetCDF variable ; if count_nc is absent, the rank of argument values is lower than or equal to the rank of the NetCDF variable. There is an optional argument, new_missing , which is not in the Fortran 90 NetCDF interface . If the argument new_missing is present then, in the returned values , the missing value from the NetCDF variable is replaced by new_missing . This may be useful for example if, in your program, you need the missing value to be ieee_value(0., IEEE_QUIET_NAN) rather than NF90_FILL_REAL . Reference: nf90_get_var nf95_gw_var (additional procedure) subroutine nf95_gw_var(ncid, varid, values) integer, intent(in):: ncid integer, intent(in):: varid any type and kind, any rank, allocatable, intent(out):: values nf95_gw_var stands for \u201cNetCDF95 get whole variable\u201d. This procedure reads a whole NetCDF variable into an array. When you want all the values of the NetCDF variable, this procedure is a shortcut to: inquiring about the dimension IDs of the variable, inquiring about the length of each dimension found, allocating the Fortran variable, reading the values from the NetCDF variable. The procedure checks that the rank of the argument values equals the rank of the NetCDF variable. The procedure does not require nor check that the type of values corresponds to the type of the NetCDF variable: conversion will occur if necessary. See reminder on allocatable arguments . nf95_inq_varid (basic change) subroutine nf95_inq_varid(ncid, name, varid, ncerr) integer, intent(in) :: ncid character (len = *), intent(in) :: name integer, intent(out) :: varid integer, intent(out), optional:: ncerr Reference: nf90_inq_varid nf95_inquire_variable (functionality change) subroutine nf95_inquire_variable(ncid, varid, name, xtype, ndims, dimids, & nAtts, ncerr) integer, intent(in):: ncid, varid character(len = *), optional, intent(out):: name integer, optional, intent(out) :: xtype, ndims integer, dimension(:), optional, allocatable, intent(out) :: dimids integer, optional, intent(out) :: nAtts integer, intent(out), optional :: ncerr In the \u201cnew\u201d nf95_inquire_variable , the argument dimids has the allocatable attribute. The procedure nf95_inquire_variable allocates and defines dimids if the argument is present. dimids is defined as a zero-sized array if the NetCDF variable is a scalar with no dimension. In the \u201cold\u201d nf90_inquire_variable , dimids was an assumed-size array. This was Fortran 77 style, not optimal. You had to allocate dimids in the calling procedure with a maximum possible number of dimensions. You also needed to call nf90_inquire_variable with the argument ndims present, to tell you which part of dimids was defined. See reminder on allocatable arguments . Reference: nf90_inquire_variable nf95_put_var (functionality change) subroutine nf95_put_var(ncid, varid, values, start, & ncerr) integer, intent(in) :: ncid, varid any type and any kind, intent(in) :: values integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map integer, intent(out), optional:: ncerr (argument values is a scalar then arguments count_nc , stride and map must not be present) or subroutine nf95_put_var(ncid, varid, values, start, & count_nc, stride, map, ncerr) integer, intent(in) :: ncid, varid any type and any kind, any rank >= 1, intent(in) :: values integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map integer, intent(out), optional:: ncerr (argument values is an array then arguments count_nc , stride and map may be present) The argument for the number of indices selected along each dimension is called count_nc in nf95_put_var , instead of count in nf90_put_var . count is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. nf95_put_var checks that : the size of arguments start and count_nc equals the rank of the NetCDF variable ; if count_nc is absent, the rank of argument values is lower than or equal to the rank of the NetCDF variable. Reference: nf90_put_var","title":"Variables"},{"location":"Detailed_content/variables/#variables","text":"This page describles procedures handling NetCDF variables. See the improvements page for an explanation of the mnemonics \u201cbasic change\u201d, \u201cinterface change\u201d, \u201cfunctionality change\u201d, \u201cadditional procedure\u201d.","title":"Variables"},{"location":"Detailed_content/variables/#reminder-on-allocatable-arguments","text":"Some NetCDF95 procedures below have a dummy argument with attributes allocatable and intent(out) . Recall that in this case the associated actual argument must also have the allocatable attribute. If it is allocated before the call, it will automatically be deallocated and reallocated in the NetCDF95 procedure.","title":"Reminder on allocatable arguments"},{"location":"Detailed_content/variables/#nf95_def_var-and-nf95_def_var_scalar","text":"(interface change) subroutine nf95_def_var_scalar(ncid, name, xtype, varid, ncerr) integer, intent( in) :: ncid character (len = *), intent( in) :: name integer, intent( in) :: xtype integer, intent(out) :: varid integer, intent(out), optional:: ncerr subroutine nf95_def_var(ncid, name, xtype, dimids, varid, ncerr) integer, intent( in) :: ncid character (len = *), intent( in) :: name integer, intent( in) :: xtype integer[, dimension(:)], intent( in) :: dimids integer, intent(out) :: varid integer, intent(out), optional:: ncerr ( dimids may be either a scalar or a rank 1 array.) Because of the additional optional argument ncerr , the generic procedure name nf95_def_var cannot include the case of a scalar variable. So there is a specific public procedure nf95_def_var_scalar for this case. Reference: nf90_def_var","title":"nf95_def_var and nf95_def_var_scalar"},{"location":"Detailed_content/variables/#nf95_get_var","text":"(functionality change) subroutine nf95_get_var(ncid, varid, values, start, & new_missing, ncerr) integer, intent(in) :: ncid, varid any type, intent(out):: values integer, dimension(:), optional, intent(in):: start same type as values, optional, intent(in):: new_missing integer, intent(out), optional:: ncerr (if argument values is a scalar then arguments count_nc , stride and map must not be present) or subroutine nf95_get_var(ncid, varid, values, start, & count_nc, stride, map, new_missing, ncerr) integer, intent(in) :: ncid, varid any type and any rank >= 1, intent(out):: values integer, dimension(:), optional, intent(in):: start, count_nc, stride, map same type as values, optional, intent(in):: new_missing integer, intent(out), optional:: ncerr (if argument values is an array then arguments count_nc , stride and map may be present) The argument for the number of indices selected along each dimension is called count_nc in nf95_get_var , instead of count in nf90_get_var . count is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. nf95_get_var checks that : the size of arguments start and count_nc equals the rank of the NetCDF variable ; if count_nc is absent, the rank of argument values is lower than or equal to the rank of the NetCDF variable. There is an optional argument, new_missing , which is not in the Fortran 90 NetCDF interface . If the argument new_missing is present then, in the returned values , the missing value from the NetCDF variable is replaced by new_missing . This may be useful for example if, in your program, you need the missing value to be ieee_value(0., IEEE_QUIET_NAN) rather than NF90_FILL_REAL . Reference: nf90_get_var","title":"nf95_get_var"},{"location":"Detailed_content/variables/#nf95_gw_var","text":"(additional procedure) subroutine nf95_gw_var(ncid, varid, values) integer, intent(in):: ncid integer, intent(in):: varid any type and kind, any rank, allocatable, intent(out):: values nf95_gw_var stands for \u201cNetCDF95 get whole variable\u201d. This procedure reads a whole NetCDF variable into an array. When you want all the values of the NetCDF variable, this procedure is a shortcut to: inquiring about the dimension IDs of the variable, inquiring about the length of each dimension found, allocating the Fortran variable, reading the values from the NetCDF variable. The procedure checks that the rank of the argument values equals the rank of the NetCDF variable. The procedure does not require nor check that the type of values corresponds to the type of the NetCDF variable: conversion will occur if necessary. See reminder on allocatable arguments .","title":"nf95_gw_var"},{"location":"Detailed_content/variables/#nf95_inq_varid","text":"(basic change) subroutine nf95_inq_varid(ncid, name, varid, ncerr) integer, intent(in) :: ncid character (len = *), intent(in) :: name integer, intent(out) :: varid integer, intent(out), optional:: ncerr Reference: nf90_inq_varid","title":"nf95_inq_varid"},{"location":"Detailed_content/variables/#nf95_inquire_variable","text":"(functionality change) subroutine nf95_inquire_variable(ncid, varid, name, xtype, ndims, dimids, & nAtts, ncerr) integer, intent(in):: ncid, varid character(len = *), optional, intent(out):: name integer, optional, intent(out) :: xtype, ndims integer, dimension(:), optional, allocatable, intent(out) :: dimids integer, optional, intent(out) :: nAtts integer, intent(out), optional :: ncerr In the \u201cnew\u201d nf95_inquire_variable , the argument dimids has the allocatable attribute. The procedure nf95_inquire_variable allocates and defines dimids if the argument is present. dimids is defined as a zero-sized array if the NetCDF variable is a scalar with no dimension. In the \u201cold\u201d nf90_inquire_variable , dimids was an assumed-size array. This was Fortran 77 style, not optimal. You had to allocate dimids in the calling procedure with a maximum possible number of dimensions. You also needed to call nf90_inquire_variable with the argument ndims present, to tell you which part of dimids was defined. See reminder on allocatable arguments . Reference: nf90_inquire_variable","title":"nf95_inquire_variable"},{"location":"Detailed_content/variables/#nf95_put_var","text":"(functionality change) subroutine nf95_put_var(ncid, varid, values, start, & ncerr) integer, intent(in) :: ncid, varid any type and any kind, intent(in) :: values integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map integer, intent(out), optional:: ncerr (argument values is a scalar then arguments count_nc , stride and map must not be present) or subroutine nf95_put_var(ncid, varid, values, start, & count_nc, stride, map, ncerr) integer, intent(in) :: ncid, varid any type and any kind, any rank >= 1, intent(in) :: values integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map integer, intent(out), optional:: ncerr (argument values is an array then arguments count_nc , stride and map may be present) The argument for the number of indices selected along each dimension is called count_nc in nf95_put_var , instead of count in nf90_put_var . count is not a good choice for a variable name because it is the name of a Fortran intrinsic procedure. nf95_put_var checks that : the size of arguments start and count_nc equals the rank of the NetCDF variable ; if count_nc is absent, the rank of argument values is lower than or equal to the rank of the NetCDF variable. Reference: nf90_put_var","title":"nf95_put_var"}]}